# coding: utf-8

"""
    Insights.Api

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import date, datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import List, Optional

from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_balancing_services_volume_data import InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_bid_offer_acceptance_level_dataset_response import InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_bid_offer_dataset_response import InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_credit_default_notice_dataset_response import InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_disaggregated_balancing_services_adjustment_data import InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_market_index_dataset_response import InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse
from openapi_client.models.insights_api_models_responses_balancing_dataset_rows_net_balancing_services_adjustment_data import InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_period_max_data import InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_period_min_data import InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_volume_max_data import InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_dataset_rows_notice_data import InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_dataset_rows_stable_portage_limit_data import InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData
from openapi_client.models.insights_api_models_responses_balancing_dynamic_rate_data import InsightsApiModelsResponsesBalancingDynamicRateData
from openapi_client.models.insights_api_models_responses_balancing_physical_dataset_rows_delivery_limit_max_data import InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData
from openapi_client.models.insights_api_models_responses_balancing_physical_dataset_rows_physical_notification_data import InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_balancing_services_volume_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_bid_offer_acceptance_level_dataset_response import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_bid_offer_dataset_response import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_credit_default_notice_dataset_response import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_disaggregated_balancing_services_adjustment_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_market_index_dataset_response import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dataset_rows_net_balancing_services_adjustment_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_period_max_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_period_min_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_dataset_rows_delivery_volume_max_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_dataset_rows_notice_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_dataset_rows_stable_portage_limit_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_dynamic_rate_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_physical_dataset_rows_delivery_limit_max_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_balancing_physical_dataset_rows_physical_notification_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_day_ahead import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_day_ahead import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_outturn_dataset_rows_demand_outturn_national import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnNational
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_outturn_dataset_rows_demand_outturn_transmission import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnTransmission
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_demand_outturn_dataset_rows_indod_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_forecast_margin_dataset_rows_forecast_margin_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_forecast_margin_dataset_rows_forecast_margin_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_forecast_surplus_dataset_rows_forecast_surplus_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_forecast_surplus_dataset_rows_forecast_surplus_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_augmented_outturn_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_by_bm_unit_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_by_bm_unit_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_by_fuel_type_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_by_fuel_type_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_daily import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityDaily
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_availability_weekly import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityWeekly
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_non_bm_stor_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_generation_dataset_rows_wind_generation_forecast import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_indicated_forecast_dataset_rows_indicated_demand import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_indicated_forecast_dataset_rows_indicated_generation import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_indicated_forecast_dataset_rows_indicated_imbalance import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_indicated_forecast_dataset_rows_indicated_margin import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_misc_dataset_rows_demand_control_instruction_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_misc_dataset_rows_loss_of_load_probability_derated_margin_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_misc_dataset_rows_system_frequency import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_misc_dataset_rows_system_warnings_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_misc_dataset_rows_temperature_data import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsTemperatureData
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_reference_dataset_metadata_latest_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesReferenceDatasetMetadataLatestRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_abuc_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_actual_aggregated_generation_per_type_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_actual_generation_output_per_generation_unit_dataset_response import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_actual_generation_wind_solar_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_actual_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_costs_of_congestion_management_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_day_ahead_aggregated_generation_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_day_ahead_generation_for_wind_and_solar_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_day_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_igca_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_month_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_week_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_year_ahead_forecast_margin_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_dataset_rows_year_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_dataset_response1_insights_api_models_responses_transparency_remit_dataset_rows_remit_message import InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_daily import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_day_ahead import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_national_weekly import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_daily import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_day_ahead import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead
from openapi_client.models.insights_api_models_responses_demand_forecast_dataset_rows_demand_forecast_transmission_weekly import InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly
from openapi_client.models.insights_api_models_responses_demand_outturn_dataset_rows_indod_dataset_row import InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow
from openapi_client.models.insights_api_models_responses_forecast_margin_dataset_rows_forecast_margin_daily import InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily
from openapi_client.models.insights_api_models_responses_forecast_margin_dataset_rows_forecast_margin_weekly import InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly
from openapi_client.models.insights_api_models_responses_forecast_surplus_dataset_rows_forecast_surplus_daily import InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily
from openapi_client.models.insights_api_models_responses_forecast_surplus_dataset_rows_forecast_surplus_weekly import InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly
from openapi_client.models.insights_api_models_responses_generation_dataset_rows_augmented_outturn_data import InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData
from openapi_client.models.insights_api_models_responses_generation_dataset_rows_availability_by_bm_unit_daily import InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily
from openapi_client.models.insights_api_models_responses_generation_dataset_rows_availability_by_bm_unit_weekly import InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly
from openapi_client.models.insights_api_models_responses_generation_dataset_rows_non_bm_stor_data import InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData
from openapi_client.models.insights_api_models_responses_generation_dataset_rows_wind_generation_forecast import InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast
from openapi_client.models.insights_api_models_responses_indicated_forecast_dataset_rows_indicated_demand import InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand
from openapi_client.models.insights_api_models_responses_indicated_forecast_dataset_rows_indicated_generation import InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration
from openapi_client.models.insights_api_models_responses_indicated_forecast_dataset_rows_indicated_imbalance import InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance
from openapi_client.models.insights_api_models_responses_indicated_forecast_dataset_rows_indicated_margin import InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin
from openapi_client.models.insights_api_models_responses_misc_dataset_rows_demand_control_instruction_dataset_row import InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow
from openapi_client.models.insights_api_models_responses_misc_dataset_rows_loss_of_load_probability_derated_margin_data import InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData
from openapi_client.models.insights_api_models_responses_misc_dataset_rows_system_frequency import InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency
from openapi_client.models.insights_api_models_responses_misc_dataset_rows_system_warnings_data import InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_abuc_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_actual_aggregated_generation_per_type_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_actual_generation_output_per_generation_unit_dataset_response import InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_actual_generation_wind_solar_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_actual_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_costs_of_congestion_management_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_day_ahead_aggregated_generation_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_day_ahead_generation_for_wind_and_solar_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_day_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_igca_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_month_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_week_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_year_ahead_forecast_margin_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_dataset_rows_year_ahead_total_load_per_bidding_zone_dataset_row import InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow
from openapi_client.models.insights_api_models_responses_transparency_remit_dataset_rows_remit_message import InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DatasetsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def datasets_abuc_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow:  # noqa: E501
        """Amount Of Balancing Reserves Under Contract (ABUC / B1720)  # noqa: E501

        This endpoint provides amount of balancing reserves under contract data.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_abuc_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_abuc_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_abuc_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_abuc_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Amount Of Balancing Reserves Under Contract (ABUC / B1720)  # noqa: E501

        This endpoint provides amount of balancing reserves under contract data.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_abuc_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_abuc_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/ABUC', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_abuc_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow]:  # noqa: E501
        """Amount Of Balancing Reserves Under Contract (ABUC / B1720) stream  # noqa: E501

        This endpoint provides amount of balancing reserves under contract data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_abuc_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_abuc_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_abuc_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_abuc_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Amount Of Balancing Reserves Under Contract (ABUC / B1720) stream  # noqa: E501

        This endpoint provides amount of balancing reserves under contract data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_abuc_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_abuc_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsAbucDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/ABUC/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_agpt_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow:  # noqa: E501
        """Actual Aggregated Generation Per Type (AGPT / B1620)  # noqa: E501

        This endpoint provides actual generation data per settlement period aggregated by Power System Resource type (Fuel Type categories as defined by Commission Regulation (EU) No 543/2013).                This endpoint filters by publishTime and provides a maximum data output range of 4 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agpt_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_agpt_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_agpt_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_agpt_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Aggregated Generation Per Type (AGPT / B1620)  # noqa: E501

        This endpoint provides actual generation data per settlement period aggregated by Power System Resource type (Fuel Type categories as defined by Commission Regulation (EU) No 543/2013).                This endpoint filters by publishTime and provides a maximum data output range of 4 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agpt_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_agpt_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/AGPT', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_agpt_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow]:  # noqa: E501
        """Actual Aggregated Generation Per Type (AGPT / B1620) stream  # noqa: E501

        This endpoint provides actual generation data per settlement period aggregated by Power System Resource type (Fuel Type categories as defined by Commission Regulation (EU) No 543/2013).                This endpoint filters by publishTime and has an optimised JSON payload aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agpt_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_agpt_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_agpt_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_agpt_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Aggregated Generation Per Type (AGPT / B1620) stream  # noqa: E501

        This endpoint provides actual generation data per settlement period aggregated by Power System Resource type (Fuel Type categories as defined by Commission Regulation (EU) No 543/2013).                This endpoint filters by publishTime and has an optimised JSON payload aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agpt_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_agpt_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsActualAggregatedGenerationPerTypeDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/AGPT/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_agws_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow:  # noqa: E501
        """Actual Or Estimated Wind And Solar Power Generation (AGWS / B1630)  # noqa: E501

        This endpoint provides actual or estimated wind and solar power generation  per settlement period. It returns generation with Power System Resource type  Solar, Wind Onshore or Wind Offshore (Fuel Type categories as defined by  Commission Regulation (EU) No 543/2013).                This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agws_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_agws_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_agws_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_agws_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Or Estimated Wind And Solar Power Generation (AGWS / B1630)  # noqa: E501

        This endpoint provides actual or estimated wind and solar power generation  per settlement period. It returns generation with Power System Resource type  Solar, Wind Onshore or Wind Offshore (Fuel Type categories as defined by  Commission Regulation (EU) No 543/2013).                This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agws_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_agws_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/AGWS', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_agws_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow]:  # noqa: E501
        """Actual Or Estimated Wind And Solar Power Generation (AGWS / B1630) stream  # noqa: E501

        This endpoint provides actual or estimated wind and solar power generation  per settlement period. It returns generation with Power System Resource type  Solar, Wind Onshore or Wind Offshore (Fuel Type categories as defined by  Commission Regulation (EU) No 543/2013).                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agws_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_agws_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_agws_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_agws_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Or Estimated Wind And Solar Power Generation (AGWS / B1630) stream  # noqa: E501

        This endpoint provides actual or estimated wind and solar power generation  per settlement period. It returns generation with Power System Resource type  Solar, Wind Onshore or Wind Offshore (Fuel Type categories as defined by  Commission Regulation (EU) No 543/2013).                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_agws_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_agws_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationWindSolarDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/AGWS/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_atl_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow:  # noqa: E501
        """Actual Total Load Per Bidding Zone (ATL / B0610)  # noqa: E501

        This endpoint provides actual total load per bidding zone data.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_atl_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_atl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_atl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_atl_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Total Load Per Bidding Zone (ATL / B0610)  # noqa: E501

        This endpoint provides actual total load per bidding zone data.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_atl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_atl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/ATL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_atl_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow]:  # noqa: E501
        """Actual Total Load Per Bidding Zone (ATL / B0610) stream  # noqa: E501

        This endpoint provides actual total load per bidding zone data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_atl_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_atl_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_atl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_atl_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Total Load Per Bidding Zone (ATL / B0610) stream  # noqa: E501

        This endpoint provides actual total load per bidding zone data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_atl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_atl_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsActualTotalLoadPerBiddingZoneDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/ATL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_b1610_get(self, settlement_date : datetime, settlement_period : StrictInt, bm_unit : Optional[conlist(StrictStr)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse:  # noqa: E501
        """Actual Generation Output Per Generation Unit (B1610)  # noqa: E501

        This endpoint provides the actual generation output (MW) per Settlement Period and per generation unit of 100 MW or more installed generation capacity.                The information is published five days after the end of the operational period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_b1610_get(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: (required)
        :type settlement_date: datetime
        :param settlement_period: (required)
        :type settlement_period: int
        :param bm_unit:
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_b1610_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_b1610_get_with_http_info(settlement_date, settlement_period, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_b1610_get_with_http_info(self, settlement_date : datetime, settlement_period : StrictInt, bm_unit : Optional[conlist(StrictStr)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Generation Output Per Generation Unit (B1610)  # noqa: E501

        This endpoint provides the actual generation output (MW) per Settlement Period and per generation unit of 100 MW or more installed generation capacity.                The information is published five days after the end of the operational period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_b1610_get_with_http_info(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: (required)
        :type settlement_date: datetime
        :param settlement_period: (required)
        :type settlement_period: int
        :param bm_unit:
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date',
            'settlement_period',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_b1610_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date') is not None:  # noqa: E501
            if isinstance(_params['settlement_date'], datetime):
                _query_params.append(('settlementDate', _params['settlement_date'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('settlementDate', _params['settlement_date']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/B1610', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_b1610_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Optional[conlist(StrictStr)] = None, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse]:  # noqa: E501
        """Actual Generation Output Per Generation Unit (B1610) stream  # noqa: E501

        This endpoint provides the actual generation output (MW) per Settlement Period and per generation unit of 100 MW or more installed generation capacity.                The information is published five days after the end of the operational period.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_b1610_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit:
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_b1610_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_b1610_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_b1610_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Optional[conlist(StrictStr)] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Actual Generation Output Per Generation Unit (B1610) stream  # noqa: E501

        This endpoint provides the actual generation output (MW) per Settlement Period and per generation unit of 100 MW or more installed generation capacity.                The information is published five days after the end of the operational period.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_b1610_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit:
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_b1610_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsActualGenerationOutputPerGenerationUnitDatasetResponse]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/B1610/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_boalf_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse:  # noqa: E501
        """Bid Offer Acceptance Level Flagged (BOALF)  # noqa: E501

        This endpoint provides bid offer acceptance data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_boalf_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_boalf_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_boalf_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_boalf_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Bid Offer Acceptance Level Flagged (BOALF)  # noqa: E501

        This endpoint provides bid offer acceptance data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/boalf?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_boalf_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_boalf_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/BOALF', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_boalf_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse]:  # noqa: E501
        """Bid Offer Acceptance Level Flagged Stream (BOALF)  # noqa: E501

        This endpoint provides bid offer acceptance data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_boalf_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_boalf_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_boalf_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_boalf_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Bid Offer Acceptance Level Flagged Stream (BOALF)  # noqa: E501

        This endpoint provides bid offer acceptance data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/boalf/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_boalf_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_boalf_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferAcceptanceLevelDatasetResponse]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/BOALF/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_bod_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse:  # noqa: E501
        """Bid Offer Data (BOD)  # noqa: E501

        This endpoint provides bid-offer data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from a datetime to a datetime                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from a datetime to a settlement date and period:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from a settlement date and period to a datetime:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from a settlement date and period to a settlement date and period:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_bod_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_bod_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_bod_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_bod_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Bid Offer Data (BOD)  # noqa: E501

        This endpoint provides bid-offer data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from a datetime to a datetime                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from a datetime to a settlement date and period:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from a settlement date and period to a datetime:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from a settlement date and period to a settlement date and period:                    /datasets/bod?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_bod_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_bod_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/BOD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_bod_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse]:  # noqa: E501
        """Bid Offer Data Stream (BOD)  # noqa: E501

        This endpoint provides bid-offer data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_bod_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_bod_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_bod_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_bod_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Bid Offer Data Stream (BOD)  # noqa: E501

        This endpoint provides bid-offer data.                By default, the from and to parameters filter the data inclusively and this endpoint will return any data where  TimeFrom is within the requested time range. If the settlementPeriodFrom or settlementPeriodTo parameters are  provided, it will instead filter to return any data where TimeFrom is within the specified range of settlement  periods. It is possible to search using a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored.  For example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from datetime to datetime                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from datetime to settlement date and period:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to datetime:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/bod/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_bod_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_bod_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsBidOfferDatasetResponse]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/BOD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ccm_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow:  # noqa: E501
        """Cost of Congestion Management (CCM / B1330)  # noqa: E501

        This endpoint provides cost of congestion management data.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ccm_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ccm_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ccm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ccm_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Cost of Congestion Management (CCM / B1330)  # noqa: E501

        This endpoint provides cost of congestion management data.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ccm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ccm_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/CCM', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ccm_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow]:  # noqa: E501
        """Cost of Congestion Management (CCM / B1330) stream  # noqa: E501

        This endpoint provides cost of congestion management data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ccm_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ccm_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ccm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ccm_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Cost of Congestion Management (CCM / B1330) stream  # noqa: E501

        This endpoint provides cost of congestion management data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ccm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ccm_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsCostsOfCongestionManagementDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/CCM/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_cdn_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, bsc_party_id : Optional[StrictStr] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse:  # noqa: E501
        """Credit Default Notice (CDN)  # noqa: E501

        This endpoint provides CDN Index Data received from EC.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_cdn_get(publish_date_time_from, publish_date_time_to, bsc_party_id, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param bsc_party_id:
        :type bsc_party_id: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_cdn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_cdn_get_with_http_info(publish_date_time_from, publish_date_time_to, bsc_party_id, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_cdn_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, bsc_party_id : Optional[StrictStr] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Credit Default Notice (CDN)  # noqa: E501

        This endpoint provides CDN Index Data received from EC.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_cdn_get_with_http_info(publish_date_time_from, publish_date_time_to, bsc_party_id, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param bsc_party_id:
        :type bsc_party_id: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'bsc_party_id',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_cdn_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bsc_party_id') is not None:  # noqa: E501
            _query_params.append(('bscPartyId', _params['bsc_party_id']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/CDN', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_cdn_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, bsc_party_id : Optional[StrictStr] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse]:  # noqa: E501
        """Credit Default Notice (CDN) stream  # noqa: E501

        This endpoint provides CDN Index Data received from EC.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the CDN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_cdn_stream_get(publish_date_time_from, publish_date_time_to, bsc_party_id, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param bsc_party_id:
        :type bsc_party_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_cdn_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_cdn_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, bsc_party_id, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_cdn_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, bsc_party_id : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Credit Default Notice (CDN) stream  # noqa: E501

        This endpoint provides CDN Index Data received from EC.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the CDN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_cdn_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, bsc_party_id, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param bsc_party_id:
        :type bsc_party_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'bsc_party_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_cdn_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bsc_party_id') is not None:  # noqa: E501
            _query_params.append(('bscPartyId', _params['bsc_party_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsCreditDefaultNoticeDatasetResponse]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/CDN/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dag_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow:  # noqa: E501
        """Day-Ahead Aggregated Generation (DAG / B1430)  # noqa: E501

        This endpoint provides day-ahead aggregated generation data.                It has a maximum date range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dag_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dag_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dag_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dag_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Aggregated Generation (DAG / B1430)  # noqa: E501

        This endpoint provides day-ahead aggregated generation data.                It has a maximum date range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dag_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dag_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DAG', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dag_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow]:  # noqa: E501
        """Day-Ahead Aggregated Generation (DAG / B1430) stream  # noqa: E501

        This endpoint provides day-ahead aggregated generation data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dag_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dag_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dag_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dag_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Aggregated Generation (DAG / B1430) stream  # noqa: E501

        This endpoint provides day-ahead aggregated generation data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dag_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dag_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadAggregatedGenerationDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DAG/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_datl_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow:  # noqa: E501
        """Day-Ahead Total Load Forecast Per Bidding Zone (DATL / B0620)  # noqa: E501

        This endpoint provides day-ahead total load forecast per bidding zone data.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_datl_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_datl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_datl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_datl_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Total Load Forecast Per Bidding Zone (DATL / B0620)  # noqa: E501

        This endpoint provides day-ahead total load forecast per bidding zone data.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_datl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_datl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DATL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_datl_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow]:  # noqa: E501
        """Day-Ahead Total Load Forecast Per Bidding Zone (DATL / B0620) stream  # noqa: E501

        This endpoint provides day-ahead total load forecast per bidding zone data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_datl_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_datl_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_datl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_datl_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Total Load Forecast Per Bidding Zone (DATL / B0620) stream  # noqa: E501

        This endpoint provides day-ahead total load forecast per bidding zone data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_datl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_datl_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadTotalLoadPerBiddingZoneDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DATL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dci_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow:  # noqa: E501
        """Demand Control Instruction (DCI)  # noqa: E501

        This endpoint provides demand control instruction data, filtered by publish time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dci_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dci_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dci_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dci_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand Control Instruction (DCI)  # noqa: E501

        This endpoint provides demand control instruction data, filtered by publish time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dci_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dci_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DCI', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dci_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow]:  # noqa: E501
        """Demand Control Instruction (DCI) stream  # noqa: E501

        This endpoint provides demand control instruction data, filtered by publish time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dci_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dci_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dci_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dci_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand Control Instruction (DCI) stream  # noqa: E501

        This endpoint provides demand control instruction data, filtered by publish time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dci_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dci_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesMiscDatasetRowsDemandControlInstructionDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DCI/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dgws_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow:  # noqa: E501
        """Day-Ahead Generation For Wind And Solar (DGWS / B1440)  # noqa: E501

        This endpoint provides day-ahead generation data for wind and solar.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dgws_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dgws_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dgws_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dgws_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Generation For Wind And Solar (DGWS / B1440)  # noqa: E501

        This endpoint provides day-ahead generation data for wind and solar.    This API endpoint provides a maximum data output range of 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dgws_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dgws_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DGWS', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_dgws_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow]:  # noqa: E501
        """Day-Ahead Generation For Wind And Solar (DGWS / B1440) stream  # noqa: E501

        This endpoint provides day-ahead generation data for wind and solar.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dgws_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_dgws_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_dgws_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_dgws_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-Ahead Generation For Wind And Solar (DGWS / B1440) stream  # noqa: E501

        This endpoint provides day-ahead generation data for wind and solar.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_dgws_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_dgws_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsDayAheadGenerationForWindAndSolarDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DGWS/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_disbsad_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData:  # noqa: E501
        """Disaggregated Balancing Services Adjustment Data (DISBSAD)  # noqa: E501

        This endpoint provides Disaggregated Balancing Services Adjustment data received from NGESO.                Disaggregated Balancing Services Adjustment data covers a set of adjustment actions, cost and volume values  for each Settlement Period. Adjustment costs are shown in £. Adjustment volumes are shown in MWh.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_disbsad_get(var_from, to, settlement_period_from, settlement_period_to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_disbsad_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_disbsad_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_disbsad_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Disaggregated Balancing Services Adjustment Data (DISBSAD)  # noqa: E501

        This endpoint provides Disaggregated Balancing Services Adjustment data received from NGESO.                Disaggregated Balancing Services Adjustment data covers a set of adjustment actions, cost and volume values  for each Settlement Period. Adjustment costs are shown in £. Adjustment volumes are shown in MWh.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/disbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_disbsad_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_disbsad_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DISBSAD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_disbsad_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData]:  # noqa: E501
        """Disaggregated Balancing Services Adjustment Data (DISBSAD) stream  # noqa: E501

        This endpoint provides Disaggregated Balancing Services Adjustment data received from NGESO.                Disaggregated Balancing Services Adjustment data covers a set of adjustment actions, cost and volume values  for each Settlement Period. Adjustment costs are shown in £. Adjustment volumes are shown in MWh.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for DISBSAD data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_disbsad_stream_get(var_from, to, settlement_period_from, settlement_period_to, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_disbsad_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_disbsad_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_disbsad_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Disaggregated Balancing Services Adjustment Data (DISBSAD) stream  # noqa: E501

        This endpoint provides Disaggregated Balancing Services Adjustment data received from NGESO.                Disaggregated Balancing Services Adjustment data covers a set of adjustment actions, cost and volume values  for each Settlement Period. Adjustment costs are shown in £. Adjustment volumes are shown in MWh.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/disbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for DISBSAD data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_disbsad_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_disbsad_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsDisaggregatedBalancingServicesAdjustmentData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/DISBSAD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fou2_t14_d_get(self, fuel_type : Optional[conlist(StrictStr)] = None, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, bidding_zone : Optional[conlist(StrictStr)] = None, interconnector : Optional[StrictBool] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeDaily:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Fuel Type (FOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering 2 days ahead to 14 days ahead; it is aggregated by Fuel Types categories.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fou2_t14_d_get(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, bidding_zone, interconnector, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type:
        :type fuel_type: List[str]
        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param bidding_zone:
        :type bidding_zone: List[str]
        :param interconnector:
        :type interconnector: bool
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fou2_t14_d_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fou2_t14_d_get_with_http_info(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, bidding_zone, interconnector, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fou2_t14_d_get_with_http_info(self, fuel_type : Optional[conlist(StrictStr)] = None, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, bidding_zone : Optional[conlist(StrictStr)] = None, interconnector : Optional[StrictBool] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Fuel Type (FOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering 2 days ahead to 14 days ahead; it is aggregated by Fuel Types categories.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fou2_t14_d_get_with_http_info(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, bidding_zone, interconnector, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type:
        :type fuel_type: List[str]
        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param bidding_zone:
        :type bidding_zone: List[str]
        :param interconnector:
        :type interconnector: bool
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date',
            'publish_date_time_from',
            'publish_date_time_to',
            'bidding_zone',
            'interconnector',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fou2_t14_d_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date') is not None:  # noqa: E501
            if isinstance(_params['publish_date'], date):
                _query_params.append(('publishDate', _params['publish_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publishDate', _params['publish_date']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bidding_zone') is not None:  # noqa: E501
            _query_params.append(('biddingZone', _params['bidding_zone']))
            _collection_formats['biddingZone'] = 'multi'

        if _params.get('interconnector') is not None:  # noqa: E501
            _query_params.append(('interconnector', _params['interconnector']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FOU2T14D', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fou2_t3_yw_get(self, fuel_type : Optional[conlist(StrictStr)] = None, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, week : Optional[conlist(StrictInt)] = None, year : Optional[conlist(StrictInt)] = None, bidding_zone : Optional[conlist(StrictStr)] = None, interconnector : Optional[StrictBool] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeWeekly:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Fuel Type (FOU2T3YW)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering availability data from 2 weeks ahead to 156 weeks ahead;  it is aggregated by Fuel Types categories.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fou2_t3_yw_get(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, week, year, bidding_zone, interconnector, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type:
        :type fuel_type: List[str]
        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param week:
        :type week: List[int]
        :param year:
        :type year: List[int]
        :param bidding_zone:
        :type bidding_zone: List[str]
        :param interconnector:
        :type interconnector: bool
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fou2_t3_yw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fou2_t3_yw_get_with_http_info(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, week, year, bidding_zone, interconnector, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fou2_t3_yw_get_with_http_info(self, fuel_type : Optional[conlist(StrictStr)] = None, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, week : Optional[conlist(StrictInt)] = None, year : Optional[conlist(StrictInt)] = None, bidding_zone : Optional[conlist(StrictStr)] = None, interconnector : Optional[StrictBool] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Fuel Type (FOU2T3YW)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering availability data from 2 weeks ahead to 156 weeks ahead;  it is aggregated by Fuel Types categories.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fou2_t3_yw_get_with_http_info(fuel_type, publish_date, publish_date_time_from, publish_date_time_to, week, year, bidding_zone, interconnector, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type:
        :type fuel_type: List[str]
        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param week:
        :type week: List[int]
        :param year:
        :type year: List[int]
        :param bidding_zone:
        :type bidding_zone: List[str]
        :param interconnector:
        :type interconnector: bool
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date',
            'publish_date_time_from',
            'publish_date_time_to',
            'week',
            'year',
            'bidding_zone',
            'interconnector',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fou2_t3_yw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date') is not None:  # noqa: E501
            if isinstance(_params['publish_date'], date):
                _query_params.append(('publishDate', _params['publish_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publishDate', _params['publish_date']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('week') is not None:  # noqa: E501
            _query_params.append(('week', _params['week']))
            _collection_formats['week'] = 'multi'

        if _params.get('year') is not None:  # noqa: E501
            _query_params.append(('year', _params['year']))
            _collection_formats['year'] = 'multi'

        if _params.get('bidding_zone') is not None:  # noqa: E501
            _query_params.append(('biddingZone', _params['bidding_zone']))
            _collection_formats['biddingZone'] = 'multi'

        if _params.get('interconnector') is not None:  # noqa: E501
            _query_params.append(('interconnector', _params['interconnector']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByFuelTypeWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FOU2T3YW', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_freq_get(self, measurement_date_time_from : Optional[datetime] = None, measurement_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency:  # noqa: E501
        """System Frequency (FREQ)  # noqa: E501

        The endpoint provides data that has been received every 2 minutes the Transmission System Frequency, expressed as a hertz value for one or more spot times within that 2 minute period.  The default output will be the latest published data.                A maximum limit of 24 hours is applied to this endpoint to limit response size. Use the streaming version  for larger response sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_freq_get(measurement_date_time_from, measurement_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param measurement_date_time_from:
        :type measurement_date_time_from: datetime
        :param measurement_date_time_to:
        :type measurement_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_freq_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_freq_get_with_http_info(measurement_date_time_from, measurement_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_freq_get_with_http_info(self, measurement_date_time_from : Optional[datetime] = None, measurement_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """System Frequency (FREQ)  # noqa: E501

        The endpoint provides data that has been received every 2 minutes the Transmission System Frequency, expressed as a hertz value for one or more spot times within that 2 minute period.  The default output will be the latest published data.                A maximum limit of 24 hours is applied to this endpoint to limit response size. Use the streaming version  for larger response sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_freq_get_with_http_info(measurement_date_time_from, measurement_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param measurement_date_time_from:
        :type measurement_date_time_from: datetime
        :param measurement_date_time_to:
        :type measurement_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'measurement_date_time_from',
            'measurement_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_freq_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('measurement_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['measurement_date_time_from'], datetime):
                _query_params.append(('measurementDateTimeFrom', _params['measurement_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('measurementDateTimeFrom', _params['measurement_date_time_from']))

        if _params.get('measurement_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['measurement_date_time_to'], datetime):
                _query_params.append(('measurementDateTimeTo', _params['measurement_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('measurementDateTimeTo', _params['measurement_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FREQ', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_freq_stream_get(self, measurement_date_time_from : Optional[datetime] = None, measurement_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency]:  # noqa: E501
        """System Frequency (FREQ) stream  # noqa: E501

        The endpoint provides data that has been received every 2 minutes the Transmission System Frequency, expressed as a hertz value for one or more spot times within that 2 minute period.  The default output will be the latest published data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the system frequency data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_freq_stream_get(measurement_date_time_from, measurement_date_time_to, async_req=True)
        >>> result = thread.get()

        :param measurement_date_time_from:
        :type measurement_date_time_from: datetime
        :param measurement_date_time_to:
        :type measurement_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_freq_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_freq_stream_get_with_http_info(measurement_date_time_from, measurement_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_freq_stream_get_with_http_info(self, measurement_date_time_from : Optional[datetime] = None, measurement_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """System Frequency (FREQ) stream  # noqa: E501

        The endpoint provides data that has been received every 2 minutes the Transmission System Frequency, expressed as a hertz value for one or more spot times within that 2 minute period.  The default output will be the latest published data.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the system frequency data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_freq_stream_get_with_http_info(measurement_date_time_from, measurement_date_time_to, async_req=True)
        >>> result = thread.get()

        :param measurement_date_time_from:
        :type measurement_date_time_from: datetime
        :param measurement_date_time_to:
        :type measurement_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'measurement_date_time_from',
            'measurement_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_freq_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('measurement_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['measurement_date_time_from'], datetime):
                _query_params.append(('measurementDateTimeFrom', _params['measurement_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('measurementDateTimeFrom', _params['measurement_date_time_from']))

        if _params.get('measurement_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['measurement_date_time_to'], datetime):
                _query_params.append(('measurementDateTimeTo', _params['measurement_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('measurementDateTimeTo', _params['measurement_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesMiscDatasetRowsSystemFrequency]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FREQ/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fuelhh_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData:  # noqa: E501
        """Half-hourly generation outturn by fuel type (FUELHH)  # noqa: E501

        This endpoint provides the half-hourly generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at 30-minute intervals with  average MW values over 30 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelhh_get(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fuelhh_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fuelhh_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fuelhh_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Half-hourly generation outturn by fuel type (FUELHH)  # noqa: E501

        This endpoint provides the half-hourly generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at 30-minute intervals with  average MW values over 30 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelhh_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period',
            'fuel_type',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fuelhh_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FUELHH', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fuelhh_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]:  # noqa: E501
        """Half-hourly generation outturn by fuel type (FUELHH) stream  # noqa: E501

        This endpoint provides the half-hourly generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at 30-minute intervals with  average MW values over 30 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the half-hourly generation outturn by fuel type (FUELHH) data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelhh_stream_get(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fuelhh_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fuelhh_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fuelhh_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Half-hourly generation outturn by fuel type (FUELHH) stream  # noqa: E501

        This endpoint provides the half-hourly generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at 30-minute intervals with  average MW values over 30 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the half-hourly generation outturn by fuel type (FUELHH) data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelhh_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period',
            'fuel_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fuelhh_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FUELHH/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fuelinst_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData:  # noqa: E501
        """Instantaneous generation outturn by fuel type (FUELINST)  # noqa: E501

        This endpoint provides the instantaneous generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at five-minute intervals  with average MW values over 5 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelinst_get(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fuelinst_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fuelinst_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fuelinst_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Instantaneous generation outturn by fuel type (FUELINST)  # noqa: E501

        This endpoint provides the instantaneous generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at five-minute intervals  with average MW values over 5 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelinst_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period',
            'fuel_type',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fuelinst_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FUELINST', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_fuelinst_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]:  # noqa: E501
        """Instantaneous generation outturn by fuel type (FUELINST) stream  # noqa: E501

        This endpoint provides the instantaneous generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at five-minute intervals  with average MW values over 5 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.    This endpoint has an optimised JSON payload and is aimed at frequent requests for instantaneous generation outturn by fuel type (FUELINST) data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelinst_stream_get(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_fuelinst_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_fuelinst_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_fuelinst_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, settlement_period : Annotated[Optional[conlist(StrictInt, unique_items=True)], Field(description="List of Settlement Periods")] = None, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="Fuel Type e.g. NUCLEAR")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Instantaneous generation outturn by fuel type (FUELINST) stream  # noqa: E501

        This endpoint provides the instantaneous generation outturn (Generation By Fuel type)  to give our users an indication of the generation outturn for Great Britain.  The data is aggregated by Fuel Type category and updated at five-minute intervals  with average MW values over 5 minutes for each category.                This endpoint includes additional Settlement parameters such as Settlement Dates and Settlement Period.  The Settlement Date fields cannot be set when a Publish Date field is set.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.    This endpoint has an optimised JSON payload and is aimed at frequent requests for instantaneous generation outturn by fuel type (FUELINST) data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_fuelinst_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, settlement_date_from, settlement_date_to, settlement_period, fuel_type, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param settlement_period: List of Settlement Periods
        :type settlement_period: List[int]
        :param fuel_type: Fuel Type e.g. NUCLEAR
        :type fuel_type: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period',
            'fuel_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_fuelinst_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsAugmentedOutturnData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/FUELINST/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_igca_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow:  # noqa: E501
        """Installed Generation Capacity Aggregated (IGCA / B1410)  # noqa: E501

        This endpoint provides installed generation capacity aggregated data.    This API endpoint provides a maximum data output range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_igca_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_igca_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_igca_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_igca_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Installed Generation Capacity Aggregated (IGCA / B1410)  # noqa: E501

        This endpoint provides installed generation capacity aggregated data.    This API endpoint provides a maximum data output range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_igca_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_igca_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/IGCA', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_igca_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow]:  # noqa: E501
        """Installed Generation Capacity Aggregated (IGCA / B1410) stream  # noqa: E501

        This endpoint provides installed generation capacity aggregated data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_igca_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_igca_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_igca_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_igca_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Installed Generation Capacity Aggregated (IGCA / B1410) stream  # noqa: E501

        This endpoint provides installed generation capacity aggregated data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_igca_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_igca_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsIgcaDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/IGCA/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_imbalngc_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance:  # noqa: E501
        """Day and Day-Ahead Indicated Imbalance (IMBALNGC)  # noqa: E501

        This endpoint provides the Indicated Imbalance. Data is received by daily by midday from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Imbalance forecast for  each period is the difference between the sum of the PNs submitted for generation BM Units (i.e.  the Indicated Generation), and the Transmission System Demand Forecast made by the System Operator.                This API endpoint provides a maximum data output range of 10 days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_imbalngc_get(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_imbalngc_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_imbalngc_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_imbalngc_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Imbalance (IMBALNGC)  # noqa: E501

        This endpoint provides the Indicated Imbalance. Data is received by daily by midday from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Imbalance forecast for  each period is the difference between the sum of the PNs submitted for generation BM Units (i.e.  the Indicated Generation), and the Transmission System Demand Forecast made by the System Operator.                This API endpoint provides a maximum data output range of 10 days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_imbalngc_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_imbalngc_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/IMBALNGC', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_imbalngc_stream_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance]:  # noqa: E501
        """Day and Day-Ahead Indicated Imbalance stream  # noqa: E501

        This endpoint provides the Indicated Imbalance. Data is received by daily by midday from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Imbalance forecast for  each period is the difference between the sum of the PNs submitted for generation BM Units (i.e.  the Indicated Generation), and the National Demand Forecast made by the System Operator.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_imbalngc_stream_get(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_imbalngc_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_imbalngc_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_imbalngc_stream_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Imbalance stream  # noqa: E501

        This endpoint provides the Indicated Imbalance. Data is received by daily by midday from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Imbalance forecast for  each period is the difference between the sum of the PNs submitted for generation BM Units (i.e.  the Indicated Generation), and the National Demand Forecast made by the System Operator.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_imbalngc_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_imbalngc_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedImbalance]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/IMBALNGC/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_inddem_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand:  # noqa: E501
        """Day and Day-Ahead Indicated Demand (INDDEM)  # noqa: E501

        This endpoint provides the indicated demand forecast for the current day and day-ahead received  from NGESO. The forecast is updated every half hour. The forecast for each period is the sum of  all the PNs submitted for BM Units which are forecast to be importing energy. Data is presented  an average MW for the Settlement Period.                This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_inddem_get(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_inddem_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_inddem_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_inddem_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Demand (INDDEM)  # noqa: E501

        This endpoint provides the indicated demand forecast for the current day and day-ahead received  from NGESO. The forecast is updated every half hour. The forecast for each period is the sum of  all the PNs submitted for BM Units which are forecast to be importing energy. Data is presented  an average MW for the Settlement Period.                This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_inddem_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_inddem_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDDEM', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_inddem_stream_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand]:  # noqa: E501
        """Day and Day-Ahead Indicated Demand stream  # noqa: E501

        This endpoint provides the indicated demand forecast for the current day and day-ahead received  from NGESO. The forecast is updated every half hour. The forecast for each period is the sum of  all the PNs submitted for BM Units which are forecast to be importing energy. Data is presented  an average MW for the Settlement Period.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_inddem_stream_get(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_inddem_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_inddem_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_inddem_stream_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Demand stream  # noqa: E501

        This endpoint provides the indicated demand forecast for the current day and day-ahead received  from NGESO. The forecast is updated every half hour. The forecast for each period is the sum of  all the PNs submitted for BM Units which are forecast to be importing energy. Data is presented  an average MW for the Settlement Period.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_inddem_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_inddem_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedDemand]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDDEM/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_indgen_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration:  # noqa: E501
        """Day and Day-Ahead Indicated Generation (INDGEN)  # noqa: E501

        This endpoint provides the Indicated Generation received from NGESO. Data is received daily, by  midday. Expressed as an average MW value for each Settlement period. The Indicated Generation  forecast for each period is the sum of all the PNs submitted for BM Units which are forecast to  be exporting energy, presented as a single average MW value for the Settlement Period.    This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indgen_get(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_indgen_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_indgen_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_indgen_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Generation (INDGEN)  # noqa: E501

        This endpoint provides the Indicated Generation received from NGESO. Data is received daily, by  midday. Expressed as an average MW value for each Settlement period. The Indicated Generation  forecast for each period is the sum of all the PNs submitted for BM Units which are forecast to  be exporting energy, presented as a single average MW value for the Settlement Period.    This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indgen_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_indgen_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDGEN', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_indgen_stream_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration]:  # noqa: E501
        """Day and Day-Ahead Indicated Generation stream  # noqa: E501

        This endpoint provides the Indicated Generation received from NGESO. Data is received daily, by  midday. Expressed as an average MW value for each Settlement period. The Indicated Generation  forecast for each period is the sum of all the PNs submitted for BM Units which are forecast to  be exporting energy, presented as a single average MW value for the Settlement Period.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indgen_stream_get(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_indgen_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_indgen_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_indgen_stream_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Generation stream  # noqa: E501

        This endpoint provides the Indicated Generation received from NGESO. Data is received daily, by  midday. Expressed as an average MW value for each Settlement period. The Indicated Generation  forecast for each period is the sum of all the PNs submitted for BM Units which are forecast to  be exporting energy, presented as a single average MW value for the Settlement Period.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indgen_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_indgen_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedGeneration]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDGEN/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_indo_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnNational:  # noqa: E501
        """Initial National Demand Outturn data (INDO)  # noqa: E501

        The endpoint provides data showing the initial National Demand outturn.  Data is updated at 15 min intervals containing the initial demand expressed in MW.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indo_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnNational
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_indo_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_indo_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_indo_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn data (INDO)  # noqa: E501

        The endpoint provides data showing the initial National Demand outturn.  Data is updated at 15 min intervals containing the initial demand expressed in MW.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indo_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnNational, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_indo_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnNational",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDO', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_indod_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD)  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indod_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_indod_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_indod_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_indod_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD)  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indod_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_indod_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDOD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_indod_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow]:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD) stream  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indod_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_indod_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_indod_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_indod_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD) stream  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_indod_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_indod_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandOutturnDatasetRowsIndodDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/INDOD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_itsdo_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnTransmission:  # noqa: E501
        """Initial Transmission System Outturn data (ITSDO)  # noqa: E501

        The endpoint provides data showing the Transmission System Initial Demand outturn.  Data is updated at 15 min intervals containing the initial demand expressed in MW.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_itsdo_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnTransmission
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_itsdo_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_itsdo_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_itsdo_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial Transmission System Outturn data (ITSDO)  # noqa: E501

        The endpoint provides data showing the Transmission System Initial Demand outturn.  Data is updated at 15 min intervals containing the initial demand expressed in MW.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_itsdo_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnTransmission, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_itsdo_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandOutturnDatasetRowsDemandOutturnTransmission",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/ITSDO', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_lolpdrm_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData:  # noqa: E501
        """Loss of Load Probability and De-rated Margin (LOLPDRM)  # noqa: E501

        The Loss of Load Probability and De-rated Margin data is received half-hourly from NGESO.                Loss of Load Probability (LOLP) is a measure of system reliability, calculated by NGESO for each Settlement Period,  using the methodology set out in the Loss of Load Probability Calculation Statement.                De-rated Margin is a forecast of the excess supply on the system, which has been adjusted to take account of the likely availability of electricity generators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_lolpdrm_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_lolpdrm_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_lolpdrm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_lolpdrm_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Loss of Load Probability and De-rated Margin (LOLPDRM)  # noqa: E501

        The Loss of Load Probability and De-rated Margin data is received half-hourly from NGESO.                Loss of Load Probability (LOLP) is a measure of system reliability, calculated by NGESO for each Settlement Period,  using the methodology set out in the Loss of Load Probability Calculation Statement.                De-rated Margin is a forecast of the excess supply on the system, which has been adjusted to take account of the likely availability of electricity generators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_lolpdrm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_lolpdrm_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/LOLPDRM', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_lolpdrm_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData]:  # noqa: E501
        """Loss of Load Probability and De-rated Margin (LOLPDRM) stream  # noqa: E501

        The Loss of Load Probability and De-rated Margin data is received half-hourly from NGESO.                Loss of Load Probability (LOLP) is a measure of system reliability, calculated by NGESO for each Settlement Period,  using the methodology set out in the Loss of Load Probability Calculation Statement.                De-rated Margin is a forecast of the excess supply on the system, which has been adjusted to take account of the likely availability of electricity generators.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_lolpdrm_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_lolpdrm_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_lolpdrm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_lolpdrm_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Loss of Load Probability and De-rated Margin (LOLPDRM) stream  # noqa: E501

        The Loss of Load Probability and De-rated Margin data is received half-hourly from NGESO.                Loss of Load Probability (LOLP) is a measure of system reliability, calculated by NGESO for each Settlement Period,  using the methodology set out in the Loss of Load Probability Calculation Statement.                De-rated Margin is a forecast of the excess supply on the system, which has been adjusted to take account of the likely availability of electricity generators.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_lolpdrm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_lolpdrm_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesMiscDatasetRowsLossOfLoadProbabilityDeratedMarginData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/LOLPDRM/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_matl_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow:  # noqa: E501
        """Month-Ahead Total Load Forecast Per Bidding Zone (MATL / B0640)  # noqa: E501

        This endpoint provides month-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_matl_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_matl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_matl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_matl_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Month-Ahead Total Load Forecast Per Bidding Zone (MATL / B0640)  # noqa: E501

        This endpoint provides month-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_matl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_matl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MATL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_matl_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow]:  # noqa: E501
        """Month-Ahead Total Load Forecast Per Bidding Zone (MATL / B0640) stream  # noqa: E501

        This endpoint provides month-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_matl_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_matl_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_matl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_matl_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Month-Ahead Total Load Forecast Per Bidding Zone (MATL / B0640) stream  # noqa: E501

        This endpoint provides month-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_matl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_matl_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsMonthAheadTotalLoadPerBiddingZoneDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MATL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mdp_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData:  # noqa: E501
        """Maximum Delivery Period (MDP)  # noqa: E501

        Maximum Delivery Period (MDP) is the maximum period, expressed in minutes, over which the  Maximum Delivery Volume (MDV) applies. Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid)  that a particular BM Unit may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdp_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mdp_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mdp_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mdp_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Delivery Period (MDP)  # noqa: E501

        Maximum Delivery Period (MDP) is the maximum period, expressed in minutes, over which the  Maximum Delivery Volume (MDV) applies. Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid)  that a particular BM Unit may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDP?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdp_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mdp_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MDP', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mdp_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData]:  # noqa: E501
        """Maximum Delivery Period Stream (MDP)  # noqa: E501

        This endpoint provides Maximum Delivery Period data received from NGESO.                Maximum Delivery Period (MDP) is the maximum period over which the Maximum Delivery Volume (MDV) applies.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MDP data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdp_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mdp_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mdp_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mdp_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Delivery Period Stream (MDP)  # noqa: E501

        This endpoint provides Maximum Delivery Period data received from NGESO.                Maximum Delivery Period (MDP) is the maximum period over which the Maximum Delivery Volume (MDV) applies.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDP/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MDP data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdp_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mdp_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMaxData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MDP/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mdv_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData:  # noqa: E501
        """Maximum Delivery Volume (MDV)  # noqa: E501

        This endpoint provides Maximum Delivery Volume data received from NGESO.                Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid), that a particular BM Unit  may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdv_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mdv_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mdv_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mdv_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Delivery Volume (MDV)  # noqa: E501

        This endpoint provides Maximum Delivery Volume data received from NGESO.                Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid), that a particular BM Unit  may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDV?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdv_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mdv_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MDV', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mdv_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData]:  # noqa: E501
        """Maximum Delivery Volume Stream (MDV)  # noqa: E501

        This endpoint provides Maximum Delivery Volume data received from NGESO.                Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid), that a particular BM Unit  may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MDV data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdv_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mdv_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mdv_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mdv_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Delivery Volume Stream (MDV)  # noqa: E501

        This endpoint provides Maximum Delivery Volume data received from NGESO.                Maximum Delivery Volume is the maximum number of MWh of Offer (or Bid), that a particular BM Unit  may deliver within the associated Maximum Delivery Period.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MDV/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MDV data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mdv_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mdv_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryVolumeMaxData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MDV/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_melngc_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin:  # noqa: E501
        """Day and Day-Ahead Indicated Margin (MELNGC)  # noqa: E501

        This endpoint provides the Indicated Margin. Data is received every half an hour from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Margin forecast for  each Settlement Period is the difference between the sum of the MELs submitted for that period,  and the National Demand Forecast made by the System Operator. The greater the value, the higher  the margin between available generation capacity and forecast demand - that is to say, the more  spare capacity there is forecast to be in the system.                This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_melngc_get(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_melngc_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_melngc_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_melngc_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Margin (MELNGC)  # noqa: E501

        This endpoint provides the Indicated Margin. Data is received every half an hour from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Margin forecast for  each Settlement Period is the difference between the sum of the MELs submitted for that period,  and the National Demand Forecast made by the System Operator. The greater the value, the higher  the margin between available generation capacity and forecast demand - that is to say, the more  spare capacity there is forecast to be in the system.                This API endpoint provides a maximum data output range of 10 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_melngc_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_melngc_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MELNGC', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_melngc_stream_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin]:  # noqa: E501
        """Day and Day-Ahead Indicated Margin stream  # noqa: E501

        This endpoint provides the Indicated Margin. Data is received every half an hour from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Margin forecast for  each Settlement Period is the difference between the sum of the MELs submitted for that period,  and the National Demand Forecast made by the System Operator. The greater the value, the higher  the margin between available generation capacity and forecast demand - that is to say, the more  spare capacity there is forecast to be in the system.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_melngc_stream_get(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_melngc_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_melngc_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_melngc_stream_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Indicated Margin stream  # noqa: E501

        This endpoint provides the Indicated Margin. Data is received every half an hour from NGESO.  Expressed as an average MW value for each Settlement period. The Indicated Margin forecast for  each Settlement Period is the difference between the sum of the MELs submitted for that period,  and the National Demand Forecast made by the System Operator. The greater the value, the higher  the margin between available generation capacity and forecast demand - that is to say, the more  spare capacity there is forecast to be in the system.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_melngc_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_melngc_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesIndicatedForecastDatasetRowsIndicatedMargin]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MELNGC/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mels_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData:  # noqa: E501
        """Maximum Export Limit (MELS)  # noqa: E501

        This endpoint provides Maximum Export Limit data received from NGESO.    The Maximum Export Limit is the maximum power export level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MELs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mels_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mels_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mels_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mels_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Export Limit (MELS)  # noqa: E501

        This endpoint provides Maximum Export Limit data received from NGESO.    The Maximum Export Limit is the maximum power export level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MELs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mels?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mels_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mels_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MELS', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mels_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]:  # noqa: E501
        """Maximum Export Limit Stream (MELS)  # noqa: E501

        This endpoint provides Maximum Export Limit data received from NGESO.    The Maximum Export Limit is the maximum power export level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MELs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  This endpoint has an optimised JSON payload and is aimed at frequent requests for MELS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mels_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mels_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mels_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mels_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Export Limit Stream (MELS)  # noqa: E501

        This endpoint provides Maximum Export Limit data received from NGESO.    The Maximum Export Limit is the maximum power export level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MELs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mels/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  This endpoint has an optimised JSON payload and is aimed at frequent requests for MELS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mels_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mels_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MELS/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_metadata_latest_get(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesReferenceDatasetMetadataLatestRow:  # noqa: E501
        """Returns the time when each dataset was last updated  # noqa: E501

        Depending on the dataset, this value may be taken from the timestamp on the source datafile, the  publishTime field on the dataset, or the latest available measurement time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_metadata_latest_get(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesReferenceDatasetMetadataLatestRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_metadata_latest_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_metadata_latest_get_with_http_info(format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_metadata_latest_get_with_http_info(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns the time when each dataset was last updated  # noqa: E501

        Depending on the dataset, this value may be taken from the timestamp on the source datafile, the  publishTime field on the dataset, or the latest available measurement time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_metadata_latest_get_with_http_info(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesReferenceDatasetMetadataLatestRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_metadata_latest_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesReferenceDatasetMetadataLatestRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/metadata/latest', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mid_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, data_providers : Annotated[Optional[conlist(StrictStr)], Field(description="The data providers to query. If no data provider is selected both will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse:  # noqa: E501
        """Market Index Data (MID)  # noqa: E501

        This endpoint provides Market Index Data received from NGESO.                Market Index Data is a key component in the calculation of System Buy Price and System Sell Price for each  Settlement Period. This data is received from each of the appointed Market Index Data Providers (MIDPs) and  reflects the price of wholesale electricity in Great Britain in the short term markets. The Market Index Data  which is received from each MIDP for each Settlement Period consists of a Market Index Volume and  Market Index Price, representing the volume and price of trading for the relevant period in the market operated  by the MIDP. The Market Price (the volume weighed average Market Index Price) is used to derive  the Reverse Price (SBP or SSP).\"                The two data providers available to query are N2EX (\"N2EXMIDP\") and APX (\"APXMIDP\").    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mid_get(var_from, to, settlement_period_from, settlement_period_to, data_providers, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param data_providers: The data providers to query. If no data provider is selected both will be displayed.
        :type data_providers: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mid_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mid_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, data_providers, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mid_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, data_providers : Annotated[Optional[conlist(StrictStr)], Field(description="The data providers to query. If no data provider is selected both will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Market Index Data (MID)  # noqa: E501

        This endpoint provides Market Index Data received from NGESO.                Market Index Data is a key component in the calculation of System Buy Price and System Sell Price for each  Settlement Period. This data is received from each of the appointed Market Index Data Providers (MIDPs) and  reflects the price of wholesale electricity in Great Britain in the short term markets. The Market Index Data  which is received from each MIDP for each Settlement Period consists of a Market Index Volume and  Market Index Price, representing the volume and price of trading for the relevant period in the market operated  by the MIDP. The Market Price (the volume weighed average Market Index Price) is used to derive  the Reverse Price (SBP or SSP).\"                The two data providers available to query are N2EX (\"N2EXMIDP\") and APX (\"APXMIDP\").    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mid?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mid_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, data_providers, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param data_providers: The data providers to query. If no data provider is selected both will be displayed.
        :type data_providers: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'data_providers',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mid_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('data_providers') is not None:  # noqa: E501
            _query_params.append(('dataProviders', _params['data_providers']))
            _collection_formats['dataProviders'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MID', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mid_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, data_providers : Annotated[Optional[conlist(StrictStr)], Field(description="The data providers to query. If no data provider is selected both will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse]:  # noqa: E501
        """Market Index Data Stream (MID)  # noqa: E501

        This endpoint provides Market Index Data received from NGESO.                Market Index Data is a key component in the calculation of System Buy Price and System Sell Price for each  Settlement Period. This data is received from each of the appointed Market Index Data Providers (MIDPs) and  reflects the price of wholesale electricity in Great Britain in the short term markets. The Market Index Data  which is received from each MIDP for each Settlement Period consists of a Market Index Volume and  Market Index Price, representing the volume and price of trading for the relevant period in the market operated  by the MIDP. The Market Price (the volume weighed average Market Index Price) is used to derive  the Reverse Price (SBP or SSP).\"                The two data providers available to query are N2EX (\"N2EXMIDP\") and APX (\"APXMIDP\").    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MID data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mid_stream_get(var_from, to, settlement_period_from, settlement_period_to, data_providers, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param data_providers: The data providers to query. If no data provider is selected both will be displayed.
        :type data_providers: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mid_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mid_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, data_providers, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mid_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, data_providers : Annotated[Optional[conlist(StrictStr)], Field(description="The data providers to query. If no data provider is selected both will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Market Index Data Stream (MID)  # noqa: E501

        This endpoint provides Market Index Data received from NGESO.                Market Index Data is a key component in the calculation of System Buy Price and System Sell Price for each  Settlement Period. This data is received from each of the appointed Market Index Data Providers (MIDPs) and  reflects the price of wholesale electricity in Great Britain in the short term markets. The Market Index Data  which is received from each MIDP for each Settlement Period consists of a Market Index Volume and  Market Index Price, representing the volume and price of trading for the relevant period in the market operated  by the MIDP. The Market Price (the volume weighed average Market Index Price) is used to derive  the Reverse Price (SBP or SSP).\"                The two data providers available to query are N2EX (\"N2EXMIDP\") and APX (\"APXMIDP\").    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mid/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MID data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mid_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, data_providers, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param data_providers: The data providers to query. If no data provider is selected both will be displayed.
        :type data_providers: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'data_providers'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mid_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('data_providers') is not None:  # noqa: E501
            _query_params.append(('dataProviders', _params['data_providers']))
            _collection_formats['dataProviders'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsMarketIndexDatasetResponse]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MID/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mils_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData:  # noqa: E501
        """Maximum Import Limit (MILS)  # noqa: E501

        This endpoint provides Maximum Import Limit data received from NGESO.    The maximum power import level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MILs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mils_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mils_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mils_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mils_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Import Limit (MILS)  # noqa: E501

        This endpoint provides Maximum Import Limit data received from NGESO.    The maximum power import level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MILs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mils?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mils_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mils_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MILS', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mils_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]:  # noqa: E501
        """Maximum Import Limit Stream (MILS)  # noqa: E501

        This endpoint provides Maximum Import Limit data received from NGESO.    The maximum power import level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MILs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  This endpoint has an optimised JSON payload and is aimed at frequent requests for MILS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mils_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mils_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mils_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mils_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Maximum Import Limit Stream (MILS)  # noqa: E501

        This endpoint provides Maximum Import Limit data received from NGESO.    The maximum power import level of a particular BM Unit at a particular time.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  MILs are submitted as a series of MW values and associated times in UTC.    By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/mils/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  This endpoint has an optimised JSON payload and is aimed at frequent requests for MILS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mils_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mils_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsDeliveryLimitMaxData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MILS/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mnzt_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData:  # noqa: E501
        """Minimum Non-Zero Time (MNZT)  # noqa: E501

        This endpoint provides Minimum Non Zero Time data received from NGESO.    The Minimum Non-Zero Time represents the minimum time that a BM Unit can operate at a non-zero level as a result of a Bid-Offer Acceptance.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mnzt_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mnzt_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mnzt_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mnzt_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Minimum Non-Zero Time (MNZT)  # noqa: E501

        This endpoint provides Minimum Non Zero Time data received from NGESO.    The Minimum Non-Zero Time represents the minimum time that a BM Unit can operate at a non-zero level as a result of a Bid-Offer Acceptance.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MNZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mnzt_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mnzt_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MNZT', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mnzt_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]:  # noqa: E501
        """Minimum Non-Zero Time Stream (MNZT)  # noqa: E501

        This endpoint provides Minimum Non Zero Time data received from NGESO.    The Minimum Non-Zero Time represents the minimum time that a BM Unit can operate at a non-zero level as a result of a Bid-Offer Acceptance.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1                This endpoint has an optimised JSON payload and is aimed at frequent requests for MNZT data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mnzt_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mnzt_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mnzt_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mnzt_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Minimum Non-Zero Time Stream (MNZT)  # noqa: E501

        This endpoint provides Minimum Non Zero Time data received from NGESO.    The Minimum Non-Zero Time represents the minimum time that a BM Unit can operate at a non-zero level as a result of a Bid-Offer Acceptance.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MNZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1                This endpoint has an optimised JSON payload and is aimed at frequent requests for MNZT data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mnzt_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mnzt_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MNZT/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mzt_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData:  # noqa: E501
        """Minimum Zero Time (MZT)  # noqa: E501

        This endpoint provides Minimum Zero Time data received from NGESO.    The Minimum Zero Time is the minimum time that a BM Unit which has been exporting must operate at zero or import, before returning to export;  whereas if the BM Unit has been importing, the MZT indicates the minimum time that it must operate at zero or export before returning to import,  if action by the System Operator (i.e. a Bid-Offer Acceptance) places it at such a level.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mzt_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mzt_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mzt_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mzt_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Minimum Zero Time (MZT)  # noqa: E501

        This endpoint provides Minimum Zero Time data received from NGESO.    The Minimum Zero Time is the minimum time that a BM Unit which has been exporting must operate at zero or import, before returning to export;  whereas if the BM Unit has been importing, the MZT indicates the minimum time that it must operate at zero or export before returning to import,  if action by the System Operator (i.e. a Bid-Offer Acceptance) places it at such a level.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MZT?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mzt_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mzt_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MZT', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_mzt_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]:  # noqa: E501
        """Minimum Zero Time Stream (MZT)  # noqa: E501

        This endpoint provides Minimum Zero Time data received from NGESO.    The Minimum Zero Time is the minimum time that a BM Unit which has been exporting must operate at zero or import, before returning to export;  whereas if the BM Unit has been importing, the MZT indicates the minimum time that it must operate at zero or export before returning to import,  if action by the System Operator (i.e. a Bid-Offer Acceptance) places it at such a level.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                  /// All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MZT data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mzt_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_mzt_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_mzt_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_mzt_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Minimum Zero Time Stream (MZT)  # noqa: E501

        This endpoint provides Minimum Zero Time data received from NGESO.    The Minimum Zero Time is the minimum time that a BM Unit which has been exporting must operate at zero or import, before returning to export;  whereas if the BM Unit has been importing, the MZT indicates the minimum time that it must operate at zero or export before returning to import,  if action by the System Operator (i.e. a Bid-Offer Acceptance) places it at such a level.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                  /// All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/MZT/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for MZT data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_mzt_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_mzt_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsDeliveryPeriodMinData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/MZT/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndf_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead:  # noqa: E501
        """National Day and Day-Ahead National Demand Forecast (NDF)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO. Data is available  daily and will show values for the day ahead. Expressed as an average MW  value for each Settlement period. The forecast is based on historically metered generation  output for Great Britain. This value INCLUDES transmission losses, but EXCLUDES Interconnector  flows and demand from station transformers and pumped storage units.                This API endpoint provides a maximum data output range of 10 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndf_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndf_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndf_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndf_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """National Day and Day-Ahead National Demand Forecast (NDF)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO. Data is available  daily and will show values for the day ahead. Expressed as an average MW  value for each Settlement period. The forecast is based on historically metered generation  output for Great Britain. This value INCLUDES transmission losses, but EXCLUDES Interconnector  flows and demand from station transformers and pumped storage units.                This API endpoint provides a maximum data output range of 10 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndf_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndf_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDF', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndf_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead]:  # noqa: E501
        """National Day and Day-Ahead National Demand Forecast stream  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO. Data is available  daily and will show values for the day ahead. Expressed as an average MW  value for each Settlement period. The forecast is based on historically metered generation  output for Great Britain. This value INCLUDES transmission losses, but EXCLUDES Interconnector  flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndf_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndf_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndf_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndf_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """National Day and Day-Ahead National Demand Forecast stream  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO. Data is available  daily and will show values for the day ahead. Expressed as an average MW  value for each Settlement period. The forecast is based on historically metered generation  output for Great Britain. This value INCLUDES transmission losses, but EXCLUDES Interconnector  flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndf_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndf_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDayAhead]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDF/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndfd_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) National Demand (NDFD)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API endpoint provides a maximum data output range of 92 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfd_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndfd_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndfd_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) National Demand (NDFD)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API endpoint provides a maximum data output range of 92 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndfd_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDFD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndfd_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) National Demand (NDFD)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the National Demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfd_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndfd_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndfd_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) National Demand (NDFD)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the National Demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndfd_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalDaily]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDFD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndfw_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) National Demand (NDFW)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API endpoint provides a maximum data output range of 366 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfw_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndfw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndfw_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndfw_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) National Demand (NDFW)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API endpoint provides a maximum data output range of 366 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfw_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndfw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDFW', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndfw_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) National Demand (NDFW)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the National Demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfw_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndfw_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndfw_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndfw_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) National Demand (NDFW)  # noqa: E501

        This endpoint provides the National Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the National Demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndfw_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndfw_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastNationalWeekly]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDFW/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndz_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData:  # noqa: E501
        """Notice to Deviate from Zero (NDZ)  # noqa: E501

        This endpoint provides Notice to Deviate from Zero data received from NGESO.                Notice to Deviate from Zero (NDZ) indicates the length of time required for a BM Unit to start importing or  exporting energy, from a zero Physical Notification level as a result of a Bid-Offer Acceptance, expressed in  minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndz_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndz_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndz_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndz_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deviate from Zero (NDZ)  # noqa: E501

        This endpoint provides Notice to Deviate from Zero data received from NGESO.                Notice to Deviate from Zero (NDZ) indicates the length of time required for a BM Unit to start importing or  exporting energy, from a zero Physical Notification level as a result of a Bid-Offer Acceptance, expressed in  minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NDZ?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndz_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndz_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDZ', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ndz_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]:  # noqa: E501
        """Notice to Deviate from Zero Stream (NDZ)  # noqa: E501

        This endpoint provides Notice to Deviate from Zero data received from NGESO.                Notice to Deviate from Zero (NDZ) indicates the length of time required for a BM Unit to start importing or  exporting energy, from a zero Physical Notification level as a result of a Bid-Offer Acceptance, expressed in  minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NDZ data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndz_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ndz_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ndz_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ndz_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deviate from Zero Stream (NDZ)  # noqa: E501

        This endpoint provides Notice to Deviate from Zero data received from NGESO.                Notice to Deviate from Zero (NDZ) indicates the length of time required for a BM Unit to start importing or  exporting energy, from a zero Physical Notification level as a result of a Bid-Offer Acceptance, expressed in  minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NDZ/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NDZ data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ndz_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ndz_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NDZ/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_netbsad_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData:  # noqa: E501
        """Net Balancing Services Adjustment Data (NETBSAD)  # noqa: E501

        This endpoint provides Net Balancing Services Adjustment data received from NGESO.                Net Balancing Services Adjustment data covers the buy/sell price, cost and volume adjustments for each  settlement period.                 By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_netbsad_get(var_from, to, settlement_period_from, settlement_period_to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_netbsad_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_netbsad_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_netbsad_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Net Balancing Services Adjustment Data (NETBSAD)  # noqa: E501

        This endpoint provides Net Balancing Services Adjustment data received from NGESO.                Net Balancing Services Adjustment data covers the buy/sell price, cost and volume adjustments for each  settlement period.                 By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/netbsad?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_netbsad_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_netbsad_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NETBSAD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_netbsad_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData]:  # noqa: E501
        """Net Balancing Services Adjustment Data (NETBSAD)  # noqa: E501

        This endpoint provides Net Balancing Services Adjustment data received from NGESO.                Net Balancing Services Adjustment data covers the buy/sell price, cost and volume adjustments for each  settlement period.                 By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NETBSAD data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_netbsad_stream_get(var_from, to, settlement_period_from, settlement_period_to, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_netbsad_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_netbsad_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_netbsad_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Net Balancing Services Adjustment Data (NETBSAD)  # noqa: E501

        This endpoint provides Net Balancing Services Adjustment data received from NGESO.                Net Balancing Services Adjustment data covers the buy/sell price, cost and volume adjustments for each  settlement period.                 By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/netbsad/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NETBSAD data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_netbsad_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_netbsad_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsNetBalancingServicesAdjustmentData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NETBSAD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nonbm_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data publish time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data publish time window.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData:  # noqa: E501
        """Non-BM STOR (NONBM)  # noqa: E501

        This endpoint provides data about the Short Term Operating Reserves (STOR) that have been made use of  by NGESO. This is activity that is outside of the Balancing Mechanism and takes place to meet the need to  increase generation or decrease demand.                To retrieve data from a particular time window, use the optional start and end time parameters.  These times should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.  If no time window is chosen, the default output will be the latest published data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nonbm_get(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data publish time window.
        :type var_from: datetime
        :param to: The end of the data publish time window.
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nonbm_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nonbm_get_with_http_info(var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nonbm_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data publish time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data publish time window.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Non-BM STOR (NONBM)  # noqa: E501

        This endpoint provides data about the Short Term Operating Reserves (STOR) that have been made use of  by NGESO. This is activity that is outside of the Balancing Mechanism and takes place to meet the need to  increase generation or decrease demand.                To retrieve data from a particular time window, use the optional start and end time parameters.  These times should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.  If no time window is chosen, the default output will be the latest published data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nonbm_get_with_http_info(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data publish time window.
        :type var_from: datetime
        :param to: The end of the data publish time window.
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nonbm_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NONBM', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nonbm_stream_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data publish time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data publish time window.")] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData]:  # noqa: E501
        """Non-BM STOR (NONBM) stream  # noqa: E501

        This endpoint provides data about the Short Term Operating Reserves (STOR) that have been made use of  by NGESO. This is activity that is outside of the Balancing Mechanism and takes place to meet the need to  increase generation or decrease demand.                To retrieve data from a particular time window, use the optional start and end time parameters.  These times should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.  If no time window is chosen, the default output will be the latest published data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the Non-BM STOR data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nonbm_stream_get(var_from, to, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data publish time window.
        :type var_from: datetime
        :param to: The end of the data publish time window.
        :type to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nonbm_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nonbm_stream_get_with_http_info(var_from, to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nonbm_stream_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data publish time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data publish time window.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Non-BM STOR (NONBM) stream  # noqa: E501

        This endpoint provides data about the Short Term Operating Reserves (STOR) that have been made use of  by NGESO. This is activity that is outside of the Balancing Mechanism and takes place to meet the need to  increase generation or decrease demand.                To retrieve data from a particular time window, use the optional start and end time parameters.  These times should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.  If no time window is chosen, the default output will be the latest published data.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the Non-BM STOR data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nonbm_stream_get_with_http_info(var_from, to, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data publish time window.
        :type var_from: datetime
        :param to: The end of the data publish time window.
        :type to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nonbm_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsNonBmStorData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NONBM/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nou2_t14_d_get(self, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityDaily:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated data (NOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering 2 days ahead to 14 days ahead. The data is aggregated at national level.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nou2_t14_d_get(publish_date, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nou2_t14_d_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nou2_t14_d_get_with_http_info(publish_date, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nou2_t14_d_get_with_http_info(self, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated data (NOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering 2 days ahead to 14 days ahead. The data is aggregated at national level.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nou2_t14_d_get_with_http_info(publish_date, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nou2_t14_d_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date') is not None:  # noqa: E501
            if isinstance(_params['publish_date'], date):
                _query_params.append(('publishDate', _params['publish_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publishDate', _params['publish_date']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NOU2T14D', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nou2_t3_yw_get(self, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, week : Optional[conlist(StrictInt)] = None, year : Optional[conlist(StrictInt)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityWeekly:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated data (NOU2T3YW)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering availability data from 2 weeks ahead to 156 weeks ahead.  The data is an aggregation of all Fuel Type categories at national level.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nou2_t3_yw_get(publish_date, publish_date_time_from, publish_date_time_to, week, year, format, async_req=True)
        >>> result = thread.get()

        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param week:
        :type week: List[int]
        :param year:
        :type year: List[int]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nou2_t3_yw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nou2_t3_yw_get_with_http_info(publish_date, publish_date_time_from, publish_date_time_to, week, year, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nou2_t3_yw_get_with_http_info(self, publish_date : Annotated[Optional[date], Field(description="The publish date for filtering. This must be in the format yyyy-MM-dd.")] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, week : Optional[conlist(StrictInt)] = None, year : Optional[conlist(StrictInt)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated data (NOU2T3YW)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable data  under the Grid Code) for generation and interconnector capacity, accounting for planned outages  covering availability data from 2 weeks ahead to 156 weeks ahead.  The data is an aggregation of all Fuel Type categories at national level.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nou2_t3_yw_get_with_http_info(publish_date, publish_date_time_from, publish_date_time_to, week, year, format, async_req=True)
        >>> result = thread.get()

        :param publish_date: The publish date for filtering. This must be in the format yyyy-MM-dd.
        :type publish_date: date
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param week:
        :type week: List[int]
        :param year:
        :type year: List[int]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date',
            'publish_date_time_from',
            'publish_date_time_to',
            'week',
            'year',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nou2_t3_yw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date') is not None:  # noqa: E501
            if isinstance(_params['publish_date'], date):
                _query_params.append(('publishDate', _params['publish_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publishDate', _params['publish_date']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('week') is not None:  # noqa: E501
            _query_params.append(('week', _params['week']))
            _collection_formats['week'] = 'multi'

        if _params.get('year') is not None:  # noqa: E501
            _query_params.append(('year', _params['year']))
            _collection_formats['year'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NOU2T3YW', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ntb_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData:  # noqa: E501
        """Notice to Deliver Bids (NTB)  # noqa: E501

        This endpoint provides Notice to Deliver Bids data received from NGESO.                Notice to Deliver Bids (NTB) indicates the length of time between the issuing of a Bid-Offer Acceptance and the  time when a BM Unit begins to deliver Bid volumes, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ntb_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ntb_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ntb_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ntb_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deliver Bids (NTB)  # noqa: E501

        This endpoint provides Notice to Deliver Bids data received from NGESO.                Notice to Deliver Bids (NTB) indicates the length of time between the issuing of a Bid-Offer Acceptance and the  time when a BM Unit begins to deliver Bid volumes, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTB?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ntb_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ntb_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NTB', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ntb_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]:  # noqa: E501
        """Notice to Deliver Bids Stream (NTB)  # noqa: E501

        This endpoint provides Notice to Deliver Bids data received from NGESO.                Notice to Deliver Bids (NTB) indicates the length of time between the issuing of a Bid-Offer Acceptance and the  time when a BM Unit begins to deliver Bid volumes, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NTB data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ntb_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ntb_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ntb_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ntb_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deliver Bids Stream (NTB)  # noqa: E501

        This endpoint provides Notice to Deliver Bids data received from NGESO.                Notice to Deliver Bids (NTB) indicates the length of time between the issuing of a Bid-Offer Acceptance and the  time when a BM Unit begins to deliver Bid volumes, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTB/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NTB data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ntb_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ntb_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NTB/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nto_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData:  # noqa: E501
        """Notice to Deliver Offers (NTO)  # noqa: E501

        This endpoint provides Notice to Deliver Offers data received from NGESO.                Notice to Deliver Offers (NTO) indicates the length of time required for a BM Unit to start delivering Offers  from the time that the Bid-Offer Acceptance is issued, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nto_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nto_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nto_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nto_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deliver Offers (NTO)  # noqa: E501

        This endpoint provides Notice to Deliver Offers data received from NGESO.                Notice to Deliver Offers (NTO) indicates the length of time required for a BM Unit to start delivering Offers  from the time that the Bid-Offer Acceptance is issued, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTO?from=2022-06-01T00:00Z&to=2022-06-08T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nto_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nto_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NTO', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_nto_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]:  # noqa: E501
        """Notice to Deliver Offers Stream (NTO)  # noqa: E501

        This endpoint provides Notice to Deliver Offers data received from NGESO.                Notice to Deliver Offers (NTO) indicates the length of time required for a BM Unit to start delivering Offers  from the time that the Bid-Offer Acceptance is issued, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NTO data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nto_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_nto_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_nto_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_nto_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Notice to Deliver Offers Stream (NTO)  # noqa: E501

        This endpoint provides Notice to Deliver Offers data received from NGESO.                Notice to Deliver Offers (NTO) indicates the length of time required for a BM Unit to start delivering Offers  from the time that the Bid-Offer Acceptance is issued, expressed in minutes.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/NTO/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for NTO data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_nto_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_nto_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsNoticeData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/NTO/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmf3_y2_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Generating Plant Demand Margin (OCNMF3Y2)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Margin for each week for the 2 to 156 weeks ahead.                This API endpoint has a maximum data output range of 7 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y2_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmf3_y2_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmf3_y2_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmf3_y2_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Generating Plant Demand Margin (OCNMF3Y2)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Margin for each week for the 2 to 156 weeks ahead.                This API endpoint has a maximum data output range of 7 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y2_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmf3_y2_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMF3Y2', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmf3_y2_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Generating Plant Demand Margin (OCNMF3Y2) stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Margin for each week for the 2 to 156 weeks ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y2_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmf3_y2_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmf3_y2_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmf3_y2_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Generating Plant Demand Margin (OCNMF3Y2) stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Margin for each week for the 2 to 156 weeks ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y2_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmf3_y2_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginWeekly]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMF3Y2/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmf3_y_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Surplus (OCNMF3Y)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily weekly half hour MW value of Generating Plant Demand Surplus for each week for the 2 to 156 weeks ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmf3_y_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmf3_y_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmf3_y_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Surplus (OCNMF3Y)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily weekly half hour MW value of Generating Plant Demand Surplus for each week for the 2 to 156 weeks ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmf3_y_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMF3Y', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmf3_y_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Surplus (OCNMF3Y) stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily weekly half hour MW value of Generating Plant Demand Surplus for each week for the 2 to 156 weeks ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the surplus forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmf3_y_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmf3_y_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmf3_y_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-156 weeks ahead) Surplus (OCNMF3Y) stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily weekly half hour MW value of Generating Plant Demand Surplus for each week for the 2 to 156 weeks ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the surplus forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmf3_y_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmf3_y_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusWeekly]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMF3Y/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmfd2_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Generating Plant Demand Margin (OCNMFD2)  # noqa: E501

        The Demand and Surplus forecast demand margin data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd2_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmfd2_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmfd2_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmfd2_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Generating Plant Demand Margin (OCNMFD2)  # noqa: E501

        The Demand and Surplus forecast demand margin data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd2_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmfd2_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMFD2', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmfd2_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Generating Plant Demand Margin stream  # noqa: E501

        The Demand and Surplus forecast demand margin data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd2_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmfd2_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmfd2_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmfd2_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Generating Plant Demand Margin stream  # noqa: E501

        The Demand and Surplus forecast demand margin data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd2_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmfd2_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesForecastMarginDatasetRowsForecastMarginDaily]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMFD2/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmfd_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Surplus (OCNMFD)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmfd_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmfd_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Surplus (OCNMFD)  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    This API endpoint provides a maximum data output range of 7 days.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmfd_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMFD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ocnmfd_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Surplus stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the surplus forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ocnmfd_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ocnmfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ocnmfd_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Surplus stream  # noqa: E501

        The Demand and Surplus forecast surplus data is received hourly from NGESO.  It shows the daily peak half hour MW value of Generating Plant Demand Surplus for each day for the 2 to 14 days ahead.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the surplus forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ocnmfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ocnmfd_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesForecastSurplusDatasetRowsForecastSurplusDaily]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/OCNMFD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_pn_get(self, settlement_date : Annotated[datetime, Field(..., description="The settlement date or datetime to query.")], settlement_period : Annotated[Optional[StrictInt], Field(description="The settlement period to query. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData:  # noqa: E501
        """Physical Notifications (PN)  # noqa: E501

        This endpoint provides Physical Notification data received from NGESO. It returns the data valid for a single settlement period.  A Physical Notification is the best estimate of the level of generation or demand that a participant in the BM expects a BM Unit to export or import, respectively, in a Settlement Period.                Physical Notifications are submitted as a series of point MW values.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering by datetime:                     /datasets/PN?settlementDate=2022-07-01T01:00Z                Filtering by settlement date and period:                    /datasets/PN?settlementDate=2022-07-01&settlementPeriod=5  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_pn_get(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date or datetime to query. (required)
        :type settlement_date: datetime
        :param settlement_period: The settlement period to query. This should be an integer from 1-50 inclusive.
        :type settlement_period: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_pn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_pn_get_with_http_info(settlement_date, settlement_period, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_pn_get_with_http_info(self, settlement_date : Annotated[datetime, Field(..., description="The settlement date or datetime to query.")], settlement_period : Annotated[Optional[StrictInt], Field(description="The settlement period to query. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Physical Notifications (PN)  # noqa: E501

        This endpoint provides Physical Notification data received from NGESO. It returns the data valid for a single settlement period.  A Physical Notification is the best estimate of the level of generation or demand that a participant in the BM expects a BM Unit to export or import, respectively, in a Settlement Period.                Physical Notifications are submitted as a series of point MW values.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering by datetime:                     /datasets/PN?settlementDate=2022-07-01T01:00Z                Filtering by settlement date and period:                    /datasets/PN?settlementDate=2022-07-01&settlementPeriod=5  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_pn_get_with_http_info(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date or datetime to query. (required)
        :type settlement_date: datetime
        :param settlement_period: The settlement period to query. This should be an integer from 1-50 inclusive.
        :type settlement_period: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date',
            'settlement_period',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_pn_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date') is not None:  # noqa: E501
            if isinstance(_params['settlement_date'], datetime):
                _query_params.append(('settlementDate', _params['settlement_date'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('settlementDate', _params['settlement_date']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/PN', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_pn_stream_get(self, var_from : Annotated[datetime, Field(..., description="The settlement date to query from.")], to : Annotated[datetime, Field(..., description="The settlement date to query up to.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]:  # noqa: E501
        """Physical Notifications Stream (PN)  # noqa: E501

        This endpoint provides Physical Notification data received from NGESO.  A Physical Notification is the best estimate of the level of generation or demand that a participant in the BM expects a BM Unit to export or import, respectively, in a Settlement Period.                Physical Notifications are submitted as a series of point MW values.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering from settlement datetime to settlement datetime:                     /datasets/PN/stream?from=2022-07-01T00:00Z&to=2022-07-03T06:00Z                Filtering from settlement datetime to settlement date and period:                     /datasets/PN/stream?from=2022-07-01T00:00Z&to=2022-07-03&settlementPeriodTo=15                Filtering from settlement date and period to settlement datetime:                     /datasets/PN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03T06:00Z                Filtering from settlement date and period to settlement date and period:                    /datasets/PN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03&settlementPeriodTo=15    This endpoint has an optimised JSON payload and is aimed at frequent requests for PN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_pn_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The settlement date to query from. (required)
        :type var_from: datetime
        :param to: The settlement date to query up to. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_pn_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_pn_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_pn_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The settlement date to query from.")], to : Annotated[datetime, Field(..., description="The settlement date to query up to.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Physical Notifications Stream (PN)  # noqa: E501

        This endpoint provides Physical Notification data received from NGESO.  A Physical Notification is the best estimate of the level of generation or demand that a participant in the BM expects a BM Unit to export or import, respectively, in a Settlement Period.                Physical Notifications are submitted as a series of point MW values.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering from settlement datetime to settlement datetime:                     /datasets/PN/stream?from=2022-07-01T00:00Z&to=2022-07-03T06:00Z                Filtering from settlement datetime to settlement date and period:                     /datasets/PN/stream?from=2022-07-01T00:00Z&to=2022-07-03&settlementPeriodTo=15                Filtering from settlement date and period to settlement datetime:                     /datasets/PN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03T06:00Z                Filtering from settlement date and period to settlement date and period:                    /datasets/PN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03&settlementPeriodTo=15    This endpoint has an optimised JSON payload and is aimed at frequent requests for PN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_pn_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The settlement date to query from. (required)
        :type var_from: datetime
        :param to: The settlement date to query up to. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_pn_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/PN/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_qas_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData:  # noqa: E501
        """Balancing Services Volume (QAS)  # noqa: E501

        This endpoint provides Balancing Services Volume data received from NGESO.                Balancing Services Volume is a volume which is received from the System Operator, which represents the volume  of energy (MWh) associated with the provision of Applicable Balancing Services for each relevant BM Unit and  Settlement Period.    QAS can be positive or negative and is normally only provided where there is a non-zero volume.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qas_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_qas_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_qas_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_qas_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Balancing Services Volume (QAS)  # noqa: E501

        This endpoint provides Balancing Services Volume data received from NGESO.                Balancing Services Volume is a volume which is received from the System Operator, which represents the volume  of energy (MWh) associated with the provision of Applicable Balancing Services for each relevant BM Unit and  Settlement Period.    QAS can be positive or negative and is normally only provided where there is a non-zero volume.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/qas?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qas_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_qas_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/QAS', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_qas_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData]:  # noqa: E501
        """Balancing Services Volume Stream (QAS)  # noqa: E501

        This endpoint provides Balancing Services Volume data received from NGESO.                Balancing Services Volume is a volume which is received from the System Operator, which represents the volume  of energy (MWh) associated with the provision of Applicable Balancing Services for each relevant BM Unit and  Settlement Period.    QAS can be positive or negative and is normally only provided where there is a non-zero volume.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qas_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_qas_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_qas_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_qas_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Balancing Services Volume Stream (QAS)  # noqa: E501

        This endpoint provides Balancing Services Volume data received from NGESO.                Balancing Services Volume is a volume which is received from the System Operator, which represents the volume  of energy (MWh) associated with the provision of Applicable Balancing Services for each relevant BM Unit and  Settlement Period.    QAS can be positive or negative and is normally only provided where there is a non-zero volume.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/qas/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qas_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_qas_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDatasetRowsBalancingServicesVolumeData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/QAS/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_qpn_get(self, settlement_date : Annotated[datetime, Field(..., description="The settlement date or datetime to query.")], settlement_period : Annotated[Optional[StrictInt], Field(description="The settlement period to query. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData:  # noqa: E501
        """Quiescent Physical Notifications (QPN)  # noqa: E501

        This endpoint provides Quiescent Physical Notification data received from NGESO. It returns the data valid for a single settlement period.  Quiescent Physical Notifications describe the MW levels to be deducted from the Physical Notification of a BM Unit to determine a resultant operating level.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering by datetime:                     /datasets/QPN?settlementDate=2022-07-01T01:00Z                Filtering by settlement date and period:                    /datasets/QPN?settlementDate=2022-07-01&settlementPeriod=5  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qpn_get(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date or datetime to query. (required)
        :type settlement_date: datetime
        :param settlement_period: The settlement period to query. This should be an integer from 1-50 inclusive.
        :type settlement_period: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_qpn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_qpn_get_with_http_info(settlement_date, settlement_period, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_qpn_get_with_http_info(self, settlement_date : Annotated[datetime, Field(..., description="The settlement date or datetime to query.")], settlement_period : Annotated[Optional[StrictInt], Field(description="The settlement period to query. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Quiescent Physical Notifications (QPN)  # noqa: E501

        This endpoint provides Quiescent Physical Notification data received from NGESO. It returns the data valid for a single settlement period.  Quiescent Physical Notifications describe the MW levels to be deducted from the Physical Notification of a BM Unit to determine a resultant operating level.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering by datetime:                     /datasets/QPN?settlementDate=2022-07-01T01:00Z                Filtering by settlement date and period:                    /datasets/QPN?settlementDate=2022-07-01&settlementPeriod=5  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qpn_get_with_http_info(settlement_date, settlement_period, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date or datetime to query. (required)
        :type settlement_date: datetime
        :param settlement_period: The settlement period to query. This should be an integer from 1-50 inclusive.
        :type settlement_period: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date',
            'settlement_period',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_qpn_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date') is not None:  # noqa: E501
            if isinstance(_params['settlement_date'], datetime):
                _query_params.append(('settlementDate', _params['settlement_date'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('settlementDate', _params['settlement_date']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/QPN', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_qpn_stream_get(self, var_from : Annotated[datetime, Field(..., description="The settlement date to query from.")], to : Annotated[datetime, Field(..., description="The settlement date to query up to.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]:  # noqa: E501
        """Quiescent Physical Notifications Stream (QPN)  # noqa: E501

        This endpoint provides Quiescent Physical Notification data received from NGESO.  Quiescent Physical Notifications describe the MW levels to be deducted from the Physical Notification of a BM Unit to determine a resultant operating level.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering from settlement datetime to settlement datetime:                     /datasets/QPN/stream?from=2022-07-01T00:00Z&to=2022-07-03T06:00Z                Filtering from settlement datetime to settlement date and period:                     /datasets/QPN/stream?from=2022-07-01T00:00Z&to=2022-07-03&settlementPeriodTo=15                Filtering from settlement date and period to settlement datetime:                     /datasets/QPN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03T06:00Z                Filtering from settlement date and period to settlement date and period:                    /datasets/QPN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03&settlementPeriodTo=15    This endpoint has an optimised JSON payload and is aimed at frequent requests for QPN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qpn_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The settlement date to query from. (required)
        :type var_from: datetime
        :param to: The settlement date to query up to. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_qpn_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_qpn_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_qpn_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The settlement date to query from.")], to : Annotated[datetime, Field(..., description="The settlement date to query up to.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Quiescent Physical Notifications Stream (QPN)  # noqa: E501

        This endpoint provides Quiescent Physical Notification data received from NGESO.  Quiescent Physical Notifications describe the MW levels to be deducted from the Physical Notification of a BM Unit to determine a resultant operating level.                The settlement period to query can be specified as a date and settlement period, or as a datetime  which will resolve to the settlement period that time falls within.  If a settlement period is provided, it will take precedence over the time portion of the datetime.    Some examples of date parameter combinations are shown below.                Filtering from settlement datetime to settlement datetime:                     /datasets/QPN/stream?from=2022-07-01T00:00Z&to=2022-07-03T06:00Z                Filtering from settlement datetime to settlement date and period:                     /datasets/QPN/stream?from=2022-07-01T00:00Z&to=2022-07-03&settlementPeriodTo=15                Filtering from settlement date and period to settlement datetime:                     /datasets/QPN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03T06:00Z                Filtering from settlement date and period to settlement date and period:                    /datasets/QPN/stream?from=2022-07-01&settlementPeriodFrom=3&to=2022-07-03&settlementPeriodTo=15    This endpoint has an optimised JSON payload and is aimed at frequent requests for QPN data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_qpn_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The settlement date to query from. (required)
        :type var_from: datetime
        :param to: The settlement date to query up to. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_qpn_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingPhysicalDatasetRowsPhysicalNotificationData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/QPN/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rdre_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData:  # noqa: E501
        """Run Down Rate Export (RDRE)  # noqa: E501

        This endpoint provides Run Down Rate Export data received from NGESO.                Run Down Rate Export (RDRE) expresses the rate of decrease in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdre_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rdre_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rdre_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rdre_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Down Rate Export (RDRE)  # noqa: E501

        This endpoint provides Run Down Rate Export data received from NGESO.                Run Down Rate Export (RDRE) expresses the rate of decrease in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdre?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdre_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rdre_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RDRE', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rdre_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicRateData]:  # noqa: E501
        """Run Down Rate Export (RDRE) Stream  # noqa: E501

        This endpoint provides Run Down Rate Export data received from NGESO.                Run Down Rate Export (RDRE) expresses the rate of decrease in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdre_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicRateData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rdre_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rdre_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rdre_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Down Rate Export (RDRE) Stream  # noqa: E501

        This endpoint provides Run Down Rate Export data received from NGESO.                Run Down Rate Export (RDRE) expresses the rate of decrease in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdre/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdre_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicRateData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rdre_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicRateData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RDRE/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rdri_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData:  # noqa: E501
        """Run Down Rate Import (RDRI)  # noqa: E501

        This endpoint provides Run Down Rate Import data received from NGESO.                Run Down Rate Import (RDRI) expresses the rate of increase in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdri_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rdri_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rdri_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rdri_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Down Rate Import (RDRI)  # noqa: E501

        This endpoint provides Run Down Rate Import data received from NGESO.                Run Down Rate Import (RDRI) expresses the rate of increase in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdri_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rdri_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RDRI', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rdri_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicRateData]:  # noqa: E501
        """Run Down Rate Import (RDRI) Stream  # noqa: E501

        This endpoint provides Run Down Rate Import data received from NGESO.                Run Down Rate Import (RDRI) expresses the rate of increase in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdri_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicRateData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rdri_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rdri_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rdri_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Down Rate Import (RDRI) Stream  # noqa: E501

        This endpoint provides Run Down Rate Import data received from NGESO.                Run Down Rate Import (RDRI) expresses the rate of increase in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rdri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rdri_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicRateData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rdri_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicRateData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RDRI/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_remit_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage:  # noqa: E501
        """The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT)  # noqa: E501

        The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) is an EU regulation aimed at preventing market abuse in wholesale energy markets.    This endpoint returns information provided by market participants to comply with Article 4 of Regulation on Wholesale Energy Market Integrity and Transparency (REMIT) Regulation (EU) 1227/2011.                Only JSON and XML formats are supported for this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_remit_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_remit_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_remit_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_remit_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT)  # noqa: E501

        The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) is an EU regulation aimed at preventing market abuse in wholesale energy markets.    This endpoint returns information provided by market participants to comply with Article 4 of Regulation on Wholesale Energy Market Integrity and Transparency (REMIT) Regulation (EU) 1227/2011.                Only JSON and XML formats are supported for this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_remit_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_remit_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/REMIT', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_remit_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage]:  # noqa: E501
        """The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) stream  # noqa: E501

        The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) is an EU regulation aimed at preventing market abuse in wholesale energy markets.    This endpoint returns information provided by market participants to comply with Article 4 of Regulation on Wholesale Energy Market Integrity and Transparency (REMIT) Regulation (EU) 1227/2011.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_remit_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_remit_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_remit_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_remit_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) stream  # noqa: E501

        The Regulation on Wholesale Energy Markets Integrity and Transparency (REMIT) is an EU regulation aimed at preventing market abuse in wholesale energy markets.    This endpoint returns information provided by market participants to comply with Article 4 of Regulation on Wholesale Energy Market Integrity and Transparency (REMIT) Regulation (EU) 1227/2011.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_remit_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_remit_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyRemitDatasetRowsRemitMessage]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/REMIT/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rure_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData:  # noqa: E501
        """Run Up Rate Export (RURE)  # noqa: E501

        This endpoint provides Run Up Rate Export data received from NGESO.                Run Up Rate Export (RURE) expresses the rate of increase in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rure_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rure_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rure_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rure_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Up Rate Export (RURE)  # noqa: E501

        This endpoint provides Run Up Rate Export data received from NGESO.                Run Up Rate Export (RURE) expresses the rate of increase in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rure?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rure_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rure_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RURE', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_rure_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicRateData]:  # noqa: E501
        """Run Up Rate Export (RURE) Stream  # noqa: E501

        This endpoint provides Run Up Rate Export data received from NGESO.                Run Up Rate Export (RURE) expresses the rate of increase in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rure_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicRateData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_rure_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_rure_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_rure_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Up Rate Export (RURE) Stream  # noqa: E501

        This endpoint provides Run Up Rate Export data received from NGESO.                Run Up Rate Export (RURE) expresses the rate of increase in active power production (MW/minute)  for a particular BM Unit which is exporting power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/rure/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_rure_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicRateData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_rure_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicRateData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RURE/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ruri_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData:  # noqa: E501
        """Run Up Rate Import (RURI)  # noqa: E501

        This endpoint provides Run Up Rate Import data received from NGESO.                Run Up Rate Import (RURI) expresses the rate of decrease in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ruri_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ruri_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ruri_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ruri_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Up Rate Import (RURI)  # noqa: E501

        This endpoint provides Run Up Rate Import data received from NGESO.                Run Up Rate Import (RURI) expresses the rate of decrease in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.  There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/ruri?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ruri_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ruri_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicRateData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RURI', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_ruri_stream_get(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicRateData]:  # noqa: E501
        """Run Up Rate Import (RURI) Stream  # noqa: E501

        This endpoint provides Run Up Rate Import data received from NGESO.                Run Up Rate Import (RURI) expresses the rate of decrease in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ruri_stream_get(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicRateData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_ruri_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_ruri_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_ruri_stream_get_with_http_info(self, var_from : Annotated[datetime, Field(..., description="The \"from\" start time or settlement date for the filter.")], to : Annotated[datetime, Field(..., description="The \"to\" start time or settlement date for the filter.")], settlement_period_from : Annotated[Optional[StrictInt], Field(description="The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, settlement_period_to : Annotated[Optional[StrictInt], Field(description="The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Run Up Rate Import (RURI) Stream  # noqa: E501

        This endpoint provides Run Up Rate Import data received from NGESO.                Run Up Rate Import (RURI) expresses the rate of decrease in active power consumption (MW/minute)  for a particular BM Unit which is importing power within a particular operating range.   There can be up to three of these for a given BM Unit.                By default, the from and to parameters filter the data by time inclusively. If the settlementPeriodFrom or  settlementPeriodTo parameters are provided, the corresponding from or to parameter instead filters on settlement  date, allowing for searching by a combination of time and/or settlement date & settlement period.  Note: When filtering via settlement date, from/to are treated as Dates only, with the time being ignored. For  example, 2022-06-01T00:00Z and 2022-06-01T11:11Z are both treated as the settlement date 2022-06-01.                All Dates and DateTimes should be expressed as defined within  <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\" target=\"_blank\">RFC 3339</a>.                Some examples of date parameter combinations are shown below.                Filtering from start time to start time:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z                Filtering from start time to settlement date and period:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodTo=1                Filtering from settlement date and period to start time:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1                Filtering from settlement date and period to settlement date and period:                    /datasets/ruri/stream?from=2022-06-01T00:00Z&to=2022-07-01T00:00Z&settlementPeriodFrom=1&settlementPeriodTo=1    This endpoint has an optimised JSON payload and is aimed at frequent requests for QAS data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_ruri_stream_get_with_http_info(var_from, to, settlement_period_from, settlement_period_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The \"from\" start time or settlement date for the filter. (required)
        :type var_from: datetime
        :param to: The \"to\" start time or settlement date for the filter. (required)
        :type to: datetime
        :param settlement_period_from: The \"from\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_from: int
        :param settlement_period_to: The \"to\" settlement period for the filter. This should be an integer from 1-50 inclusive.
        :type settlement_period_to: int
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicRateData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'settlement_period_from',
            'settlement_period_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_ruri_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('settlement_period_from') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodFrom', _params['settlement_period_from']))

        if _params.get('settlement_period_to') is not None:  # noqa: E501
            _query_params.append(('settlementPeriodTo', _params['settlement_period_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicRateData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/RURI/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_sel_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData:  # noqa: E501
        """Stable Export Limit (SEL)  # noqa: E501

        This endpoint provides Stable Export Limit data received from NGESO.  Stable Export Limit is a positive megawatt value, expressing the minimum stable operating level at which a particular BM Unit can export power to the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sel_get(var_from, to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_sel_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_sel_get_with_http_info(var_from, to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_sel_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stable Export Limit (SEL)  # noqa: E501

        This endpoint provides Stable Export Limit data received from NGESO.  Stable Export Limit is a positive megawatt value, expressing the minimum stable operating level at which a particular BM Unit can export power to the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sel_get_with_http_info(var_from, to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_sel_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SEL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_sel_stream_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]:  # noqa: E501
        """Stable Export Limit Stream (SEL)  # noqa: E501

        This endpoint provides Stable Export Limit data received from NGESO.  Stable Export Limit is a positive megawatt value, expressing the minimum stable operating level at which a particular BM Unit can export power to the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.                This endpoint has an optimised JSON payload and is aimed at frequent requests for SEL data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sel_stream_get(var_from, to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_sel_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_sel_stream_get_with_http_info(var_from, to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_sel_stream_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stable Export Limit Stream (SEL)  # noqa: E501

        This endpoint provides Stable Export Limit data received from NGESO.  Stable Export Limit is a positive megawatt value, expressing the minimum stable operating level at which a particular BM Unit can export power to the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.                This endpoint has an optimised JSON payload and is aimed at frequent requests for SEL data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sel_stream_get_with_http_info(var_from, to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_sel_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SEL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_sil_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData:  # noqa: E501
        """Stable Import Limit (SIL)  # noqa: E501

        This endpoint provides Stable Import Limit data received from NGESO.  Stable Import Limit is a negative megawatt value, expressing the minimum stable operating level at which a particular BM Unit can import power from the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sil_get(var_from, to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_sil_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_sil_get_with_http_info(var_from, to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_sil_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stable Import Limit (SIL)  # noqa: E501

        This endpoint provides Stable Import Limit data received from NGESO.  Stable Import Limit is a negative megawatt value, expressing the minimum stable operating level at which a particular BM Unit can import power from the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sil_get_with_http_info(var_from, to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_sil_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SIL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_sil_stream_get(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]:  # noqa: E501
        """Stable Import Limit Stream (SIL)  # noqa: E501

        This endpoint provides Stable Import Limit data received from NGESO.  Stable Import Limit is a negative megawatt value, expressing the minimum stable operating level at which a particular BM Unit can import power from the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.                This endpoint has an optimised JSON payload and is aimed at frequent requests for SIL data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sil_stream_get(var_from, to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_sil_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_sil_stream_get_with_http_info(var_from, to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_sil_stream_get_with_http_info(self, var_from : Annotated[Optional[datetime], Field(description="The start of the data time window.")] = None, to : Annotated[Optional[datetime], Field(description="The end of the data time window.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stable Import Limit Stream (SIL)  # noqa: E501

        This endpoint provides Stable Import Limit data received from NGESO.  Stable Import Limit is a negative megawatt value, expressing the minimum stable operating level at which a particular BM Unit can import power from the transmission system.                If no date window is chosen, the search will default to results from last 24 hours.                This endpoint has an optimised JSON payload and is aimed at frequent requests for SIL data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_sil_stream_get_with_http_info(var_from, to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the data time window.
        :type var_from: datetime
        :param to: The end of the data time window.
        :type to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. If no BM unit is selected all BM units will be displayed.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_sil_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesBalancingDynamicDatasetRowsStablePortageLimitData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SIL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_syswarn_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData:  # noqa: E501
        """System Warnings (SYSWARN)  # noqa: E501

        This endpoint provides system warnings data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_syswarn_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_syswarn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_syswarn_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_syswarn_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """System Warnings (SYSWARN)  # noqa: E501

        This endpoint provides system warnings data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_syswarn_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_syswarn_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SYSWARN', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_syswarn_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData]:  # noqa: E501
        """System Warnings (SYSWARN) stream  # noqa: E501

        This endpoint provides system warnings data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_syswarn_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_syswarn_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_syswarn_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_syswarn_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """System Warnings (SYSWARN) stream  # noqa: E501

        This endpoint provides system warnings data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_syswarn_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_syswarn_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesMiscDatasetRowsSystemWarningsData]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/SYSWARN/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_temp_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsTemperatureData:  # noqa: E501
        """Temperature Data (TEMP)  # noqa: E501

        This endpoint provides the average degree celsius value measured at midday deemed to be  representative of the temperature for Great Britain. Data is gathered from 6 weather stations.  Default output will be the last 31 days. Values are received from 5pm each day.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_temp_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsTemperatureData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_temp_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_temp_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_temp_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Temperature Data (TEMP)  # noqa: E501

        This endpoint provides the average degree celsius value measured at midday deemed to be  representative of the temperature for Great Britain. Data is gathered from 6 weather stations.  Default output will be the last 31 days. Values are received from 5pm each day.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_temp_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsTemperatureData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_temp_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesMiscDatasetRowsTemperatureData",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TEMP', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdf_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead:  # noqa: E501
        """Day and Day-Ahead Transmission System Demand Forecast (TSDF)  # noqa: E501

        This endpoint provides the Transmission System forecast.  Data is received daily from NGESO and will show values for the day ahead.  Expressed as an average MW value for each Settlement period.  The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdf_get(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdf_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdf_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdf_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Transmission System Demand Forecast (TSDF)  # noqa: E501

        This endpoint provides the Transmission System forecast.  Data is received daily from NGESO and will show values for the day ahead.  Expressed as an average MW value for each Settlement period.  The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdf_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdf_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDF', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdf_stream_get(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead]:  # noqa: E501
        """Day and Day-Ahead Transmission System Demand Forecast (TSDF)  # noqa: E501

        This endpoint provides the Transmission System forecast.  Data is received daily from NGESO and will show values for the day ahead.  Expressed as an average MW value for each Settlement period.  The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdf_stream_get(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdf_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdf_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdf_stream_get_with_http_info(self, boundary : Optional[StrictStr] = None, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day and Day-Ahead Transmission System Demand Forecast (TSDF)  # noqa: E501

        This endpoint provides the Transmission System forecast.  Data is received daily from NGESO and will show values for the day ahead.  Expressed as an average MW value for each Settlement period.  The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdf_stream_get_with_http_info(boundary, publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdf_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDayAhead]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDF/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdfd_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Transmission System (TSDFD)  # noqa: E501

        This end point provides the Transmission System forecast. Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.                This API endpoint provides a maximum data output range of 92 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfd_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdfd_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdfd_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Transmission System (TSDFD)  # noqa: E501

        This end point provides the Transmission System forecast. Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.                This API endpoint provides a maximum data output range of 92 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfd_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdfd_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDFD', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdfd_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Transmission System (TSDFD) stream  # noqa: E501

        This end point provides the Transmission System forecast. Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfd_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdfd_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdfd_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-14 days ahead) Transmission System (TSDFD) stream  # noqa: E501

        This end point provides the Transmission System forecast. Data is available daily and will show values for the 2 to 14 days ahead.  Expressed as an average MW value for each Settlement period. The Transmission System Demand Forecast is based on historically metered generation output for Great Britain.  This value INCLUDES Interconnector flows and demand from station transformers and pumped storage units.                Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfd_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdfd_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionDaily]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDFD/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdfw_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) Transmission System Demand (TSDFW)  # noqa: E501

        This endpoint provides the Transmission System Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API will provide a maximum data output range of 366 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfw_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdfw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdfw_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdfw_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) Transmission System Demand (TSDFW)  # noqa: E501

        This endpoint provides the Transmission System Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    This API will provide a maximum data output range of 366 days.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfw_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdfw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDFW', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_tsdfw_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly]:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) Transmission System Demand (TSDFW)  # noqa: E501

        This endpoint provides the Transmission System Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfw_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_tsdfw_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_tsdfw_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_tsdfw_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Demand and Surplus Forecast Data (2-52 weeks ahead) Transmission System Demand (TSDFW)  # noqa: E501

        This endpoint provides the Transmission System Demand forecast received from NGESO.  Data is available from 4pm each Thursday and will show values for the 2 to 52 weeks ahead.  Expressed as an average MW value for each week. The forecast is based on historically metered generation output for Great Britain.  This value INCLUDES transmission losses, but EXCLUDES Interconnector flows and demand from station.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the transmission system demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_tsdfw_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_tsdfw_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandForecastDatasetRowsDemandForecastTransmissionWeekly]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/TSDFW/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_uou2_t14_d_get(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Balancing Mechanism Units (UOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 days ahead to 14 days ahead; it is aggregated by  National Grid Balancing Mechanism Units (NGC BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t14_d_get(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_uou2_t14_d_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_uou2_t14_d_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_uou2_t14_d_get_with_http_info(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Balancing Mechanism Units (UOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 days ahead to 14 days ahead; it is aggregated by  National Grid Balancing Mechanism Units (NGC BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t14_d_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date_time_from',
            'publish_date_time_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_uou2_t14_d_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/UOU2T14D', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_uou2_t14_d_stream_get(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily]:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Balancing Mechanism Units Stream (UOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 days ahead to 14 days ahead; it is aggregated by  National Grid Balancing Mechanism Units (NGC BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t14_d_stream_get(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_uou2_t14_d_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_uou2_t14_d_stream_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_uou2_t14_d_stream_get_with_http_info(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 14 Days Ahead Generation availability aggregated by Balancing Mechanism Units Stream (UOU2T14D)  # noqa: E501

        This endpoint provides a forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 days ahead to 14 days ahead; it is aggregated by  National Grid Balancing Mechanism Units (NGC BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t14_d_stream_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date_time_from',
            'publish_date_time_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_uou2_t14_d_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitDaily]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/UOU2T14D/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_uou2_t3_yw_get(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Balancing Mechanism Units (UOU2T3YW)  # noqa: E501

        This endpoint forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 weeks ahead to 156 weeks ahead; it is aggregated by  Balancing Mechanism Units (BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t3_yw_get(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_uou2_t3_yw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_uou2_t3_yw_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_uou2_t3_yw_get_with_http_info(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Balancing Mechanism Units (UOU2T3YW)  # noqa: E501

        This endpoint forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 weeks ahead to 156 weeks ahead; it is aggregated by  Balancing Mechanism Units (BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t3_yw_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, format, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date_time_from',
            'publish_date_time_to',
            'bm_unit',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_uou2_t3_yw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/UOU2T3YW', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_uou2_t3_yw_stream_get(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly]:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Balancing Mechanism Units Stream (UOU2T3YW)  # noqa: E501

        This endpoint forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 weeks ahead to 156 weeks ahead; it is aggregated by  Balancing Mechanism Units (BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t3_yw_stream_get(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_uou2_t3_yw_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_uou2_t3_yw_stream_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_uou2_t3_yw_stream_get_with_http_info(self, fuel_type : Annotated[Optional[conlist(StrictStr)], Field(description="The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.")] = None, publish_date_time_from : Annotated[Optional[datetime], Field(description="Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.")] = None, publish_date_time_to : Annotated[Optional[datetime], Field(description="End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.")] = None, bm_unit : Annotated[Optional[conlist(StrictStr)], Field(description="The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """2 to 156 Weeks Ahead Generation availability aggregated by Balancing Mechanism Units Stream (UOU2T3YW)  # noqa: E501

        This endpoint forward view of availability (also referred to as Output Usable  data under the Grid Code) for generation and interconnector capacity, accounting for planned  outages covering availability data from 2 weeks ahead to 156 weeks ahead; it is aggregated by  Balancing Mechanism Units (BMUs).                In the context of this report, BMUs can be considered as generating units.  Elexon BMUs differs from NGC BMUs by including a prefix e.g. 'T_'.  The mapping between NGC and Elexon BMUs can be retrieved via reference data API endpoints.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_uou2_t3_yw_stream_get_with_http_info(fuel_type, publish_date_time_from, publish_date_time_to, bm_unit, async_req=True)
        >>> result = thread.get()

        :param fuel_type: The fuel type to query. Add each fuel type separately. If no fuel types are supplied, all fuel types will be returned.
        :type fuel_type: List[str]
        :param publish_date_time_from: Start of the Publish Time range to query. If specified, PublishDateTimeTo must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_from: datetime
        :param publish_date_time_to: End of the Publish Time range to query. If specified, PublishDateTimeFrom must also be specified.  If both are omitted, latest published data is returned.
        :type publish_date_time_to: datetime
        :param bm_unit: The BM units to query. Add each unit separately. Either the Elexon ID or the National Grid ID can be used.  If no BM unit is supplied all BM units will be returned.
        :type bm_unit: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'fuel_type',
            'publish_date_time_from',
            'publish_date_time_to',
            'bm_unit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_uou2_t3_yw_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('fuel_type') is not None:  # noqa: E501
            _query_params.append(('fuelType', _params['fuel_type']))
            _collection_formats['fuelType'] = 'multi'

        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('bm_unit') is not None:  # noqa: E501
            _query_params.append(('bmUnit', _params['bm_unit']))
            _collection_formats['bmUnit'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsAvailabilityByBmUnitWeekly]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/UOU2T3YW/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_watl_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow:  # noqa: E501
        """Week-Ahead Total Load Forecast Per Bidding Zone (WATL / B0630)  # noqa: E501

        This endpoint provides week-ahead total load forecast per bidding zone data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_watl_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_watl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_watl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_watl_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Week-Ahead Total Load Forecast Per Bidding Zone (WATL / B0630)  # noqa: E501

        This endpoint provides week-ahead total load forecast per bidding zone data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_watl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_watl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/WATL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_watl_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow]:  # noqa: E501
        """Week-Ahead Total Load Forecast Per Bidding Zone (WATL / B0630) stream  # noqa: E501

        This endpoint provides week-ahead total load forecast per bidding zone data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_watl_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_watl_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_watl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_watl_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Week-Ahead Total Load Forecast Per Bidding Zone (WATL / B0630) stream  # noqa: E501

        This endpoint provides week-ahead total load forecast per bidding zone data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_watl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_watl_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsWeekAheadTotalLoadPerBiddingZoneDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/WATL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_windfor_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast:  # noqa: E501
        """Wind Generation Forecast (WINDFOR)  # noqa: E501

        This endpoint provides wind generation forecast data.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_windfor_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_windfor_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_windfor_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_windfor_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Wind Generation Forecast (WINDFOR)  # noqa: E501

        This endpoint provides wind generation forecast data.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_windfor_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_windfor_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/WINDFOR', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_windfor_stream_get(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> List[InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast]:  # noqa: E501
        """Wind Generation Forecast (WINDFOR)  # noqa: E501

        This endpoint provides wind generation forecast data.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the wind generation forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_windfor_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_windfor_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_windfor_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_windfor_stream_get_with_http_info(self, publish_date_time_from : Optional[datetime] = None, publish_date_time_to : Optional[datetime] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Wind Generation Forecast (WINDFOR)  # noqa: E501

        This endpoint provides wind generation forecast data.    Specific publish time filters may be supplied, otherwise this will retrieve the latest published forecast.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the wind generation forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_windfor_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from:
        :type publish_date_time_from: datetime
        :param publish_date_time_to:
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_windfor_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesGenerationDatasetRowsWindGenerationForecast]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/WINDFOR/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_yafm_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow:  # noqa: E501
        """Year Ahead Forecast Margin (YAFM / B0810)  # noqa: E501

        This endpoint provides year-ahead forecast margin data.                A year-ahead forecast margin is defined as the difference between yearly forecast of available generation capacity and yearly forecast of total load,  taking into account the forecast of total generation capacity, forecast of availability of generation and forecast of reserves contracted for system services.    This API endpoint has a maximum range of 20 years (7305 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yafm_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_yafm_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_yafm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_yafm_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Year Ahead Forecast Margin (YAFM / B0810)  # noqa: E501

        This endpoint provides year-ahead forecast margin data.                A year-ahead forecast margin is defined as the difference between yearly forecast of available generation capacity and yearly forecast of total load,  taking into account the forecast of total generation capacity, forecast of availability of generation and forecast of reserves contracted for system services.    This API endpoint has a maximum range of 20 years (7305 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yafm_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_yafm_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/YAFM', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_yafm_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow]:  # noqa: E501
        """Year Ahead Forecast Margin (YAFM / B0810)  # noqa: E501

        This endpoint provides year-ahead forecast margin data.    A year-ahead forecast margin is defined as the difference between yearly forecast of available generation capacity and yearly forecast of total load,  taking into account the forecast of total generation capacity, forecast of availability of generation and forecast of reserves contracted for system services.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yafm_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_yafm_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_yafm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_yafm_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Year Ahead Forecast Margin (YAFM / B0810)  # noqa: E501

        This endpoint provides year-ahead forecast margin data.    A year-ahead forecast margin is defined as the difference between yearly forecast of available generation capacity and yearly forecast of total load,  taking into account the forecast of total generation capacity, forecast of availability of generation and forecast of reserves contracted for system services.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yafm_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_yafm_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadForecastMarginDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/YAFM/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_yatl_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow:  # noqa: E501
        """Year-Ahead Total Load Forecast Per Bidding Zone (YATL / B0650)  # noqa: E501

        This endpoint provides year-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yatl_get(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_yatl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_yatl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_yatl_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Year-Ahead Total Load Forecast Per Bidding Zone (YATL / B0650)  # noqa: E501

        This endpoint provides year-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This API endpoint has a maximum range of 367 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yatl_get_with_http_info(publish_date_time_from, publish_date_time_to, format, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_yatl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesDatasetResponse1InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/YATL', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def datasets_yatl_stream_get(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow]:  # noqa: E501
        """Year-Ahead Total Load Forecast Per Bidding Zone (YATL / B0650) stream  # noqa: E501

        This endpoint provides year-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yatl_stream_get(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the datasets_yatl_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.datasets_yatl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, **kwargs)  # noqa: E501

    @validate_arguments
    def datasets_yatl_stream_get_with_http_info(self, publish_date_time_from : datetime, publish_date_time_to : datetime, **kwargs) -> ApiResponse:  # noqa: E501
        """Year-Ahead Total Load Forecast Per Bidding Zone (YATL / B0650) stream  # noqa: E501

        This endpoint provides year-ahead total load per bidding zone forecast data with minimum possible  and maximum available loads provided in MW values.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_yatl_stream_get_with_http_info(publish_date_time_from, publish_date_time_to, async_req=True)
        >>> result = thread.get()

        :param publish_date_time_from: (required)
        :type publish_date_time_from: datetime
        :param publish_date_time_to: (required)
        :type publish_date_time_to: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_date_time_from',
            'publish_date_time_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_yatl_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_date_time_from') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_from'], datetime):
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeFrom', _params['publish_date_time_from']))

        if _params.get('publish_date_time_to') is not None:  # noqa: E501
            if isinstance(_params['publish_date_time_to'], datetime):
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishDateTimeTo', _params['publish_date_time_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesTransparencyDatasetRowsYearAheadTotalLoadPerBiddingZoneDatasetRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/datasets/YATL/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
