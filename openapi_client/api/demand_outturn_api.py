# coding: utf-8

"""
    Insights.Api

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import date, datetime

from pydantic import Field, StrictInt, StrictStr, conlist

from typing import List, Optional

from openapi_client.models.insights_api_models_responses_demand_outturn_demand_outturn import InsightsApiModelsResponsesDemandOutturnDemandOutturn
from openapi_client.models.insights_api_models_responses_demand_outturn_indod_row import InsightsApiModelsResponsesDemandOutturnIndodRow
from openapi_client.models.insights_api_models_responses_demand_outturn_rolling_system_demand import InsightsApiModelsResponsesDemandOutturnRollingSystemDemand
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_outturn_demand_outturn import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturn
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_outturn_demand_outturn_peak import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturnPeak
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_outturn_indicative_demand_peak import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_outturn_indod_row import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndodRow
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_outturn_rolling_system_demand import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnRollingSystemDemand

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DemandOutturnApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def demand_get(self, settlement_date_from : Annotated[Optional[date], Field(description="The settlement date from for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_date_to : Annotated[Optional[date], Field(description="The settlement date to for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_period : Optional[conlist(StrictInt, unique_items=True)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturn:  # noqa: E501
        """Initial National Demand Outturn  # noqa: E501

        This endpoint provides data for Initial National Demand Outturn, which measures the  half-hour average MW demand metered by the Transmission Company based on its operational metering.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period. The data is represented with:  - INDO (Initial National Demand Outturn) which takes into account transmission losses but does not include station transformer load, pumped storage demand or interconnector demand.  - ITSDO (Initial Transmission System Demand Outturn) which takes into account transmission losses, station transformer load, pumped storage demand and interconnector demand.                This endpoint is useful for ad-hoc querying of the initial national demand outturn data.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_get(settlement_date_from, settlement_date_to, settlement_period, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from: The settlement date from for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_from: date
        :param settlement_date_to: The settlement date to for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_to: date
        :param settlement_period:
        :type settlement_period: List[int]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturn
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_get_with_http_info(settlement_date_from, settlement_date_to, settlement_period, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_get_with_http_info(self, settlement_date_from : Annotated[Optional[date], Field(description="The settlement date from for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_date_to : Annotated[Optional[date], Field(description="The settlement date to for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_period : Optional[conlist(StrictInt, unique_items=True)] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn  # noqa: E501

        This endpoint provides data for Initial National Demand Outturn, which measures the  half-hour average MW demand metered by the Transmission Company based on its operational metering.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period. The data is represented with:  - INDO (Initial National Demand Outturn) which takes into account transmission losses but does not include station transformer load, pumped storage demand or interconnector demand.  - ITSDO (Initial Transmission System Demand Outturn) which takes into account transmission losses, station transformer load, pumped storage demand and interconnector demand.                This endpoint is useful for ad-hoc querying of the initial national demand outturn data.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_get_with_http_info(settlement_date_from, settlement_date_to, settlement_period, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from: The settlement date from for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_from: date
        :param settlement_date_to: The settlement date to for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_to: date
        :param settlement_period:
        :type settlement_period: List[int]
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturn, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturn",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_outturn_daily_get(self, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndodRow:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD)  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).                If no date window is chosen, the search will default to results from the last 31 days.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_outturn_daily_get(settlement_date_from, settlement_date_to, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndodRow
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_outturn_daily_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_outturn_daily_get_with_http_info(settlement_date_from, settlement_date_to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_outturn_daily_get_with_http_info(self, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD)  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).                If no date window is chosen, the search will default to results from the last 31 days.    This API endpoint has a maximum range of 2 years (731 days).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_outturn_daily_get_with_http_info(settlement_date_from, settlement_date_to, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndodRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date_from',
            'settlement_date_to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_outturn_daily_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndodRow",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/outturn/daily', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_outturn_daily_stream_get(self, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandOutturnIndodRow]:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD) stream  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).                If no date window is chosen, the search will default to results from the last 31 days.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_outturn_daily_stream_get(settlement_date_from, settlement_date_to, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandOutturnIndodRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_outturn_daily_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_outturn_daily_stream_get_with_http_info(settlement_date_from, settlement_date_to, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_outturn_daily_stream_get_with_http_info(self, settlement_date_from : Optional[date] = None, settlement_date_to : Optional[date] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn Daily (INDOD) stream  # noqa: E501

        This endpoint provides initial National Demand outturn daily data. The total daily energy volume is the total  demand volume for the previous day expressed on an Initial National Demand Outturn (INDO) basis, i.e. excluding  station transformer, pumping and interconnector export demand. It is calculated from summing the half hourly  INDO demands (divided by two to convert to MWh).                If no date window is chosen, the search will default to results from the last 31 days.    This endpoint has an optimised JSON payload and is aimed at frequent requests for the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_outturn_daily_stream_get_with_http_info(settlement_date_from, settlement_date_to, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from:
        :type settlement_date_from: date
        :param settlement_date_to:
        :type settlement_date_to: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandOutturnIndodRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date_from',
            'settlement_date_to'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_outturn_daily_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandOutturnIndodRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/outturn/daily/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_peak_get(self, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturnPeak:  # noqa: E501
        """Retrieve peak demand data for each day, based on ITSDO data  # noqa: E501

        This endpoint allows for retrieving peak ITSDO demand for each day from National Grid ESO.  Results are filtered by a range of Date parameters.  Results default to yesterday's peak if no parameters are supplied.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_get(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturnPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_peak_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_peak_get_with_http_info(var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_peak_get_with_http_info(self, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve peak demand data for each day, based on ITSDO data  # noqa: E501

        This endpoint allows for retrieving peak ITSDO demand for each day from National Grid ESO.  Results are filtered by a range of Date parameters.  Results default to yesterday's peak if no parameters are supplied.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_get_with_http_info(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturnPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_peak_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], date):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], date):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnDemandOutturnPeak",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/peak', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_peak_indicative_get(self, data : Annotated[StrictStr, Field(..., description="The type of data. Supports values of 'operational' or 'settlement'.")], triad_season_start_year : Annotated[Optional[StrictInt], Field(description="A year indicating the Triad season starting on 1 November of the given year, e.g. 2021.")] = None, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak:  # noqa: E501
        """Indicative Demand Peaks  # noqa: E501

        Indicative Demand Peaks using Operational Metering data are daily maxima values determined from  ITSDO and FUELHH data used to determine and visualise Triad.                Indicative Demand Peaks using Settlement Metering data are daily maxima values determined from  metered volume data from the S0142_bpi file. These peaks are not used for Triad visualisation as  they are always calculated based on the latest run type. Triads for settlement data  remain static after the National Grid report posted at the beginning of April after the Triad season has ended.                 If no filters are supplied, results default to the latest or current Triad season.  To specify a custom filter, you can supplier EITHER a Triad season start year, OR a date range, but not both.  If a Triad Season Start year is supplied, data for the Triad season beginning on 1 November  of the specified year will be returned.  If a date range is supplied, data will be returned for settlement dates within the date range inclusively.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_get(data, triad_season_start_year, var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param data: The type of data. Supports values of 'operational' or 'settlement'. (required)
        :type data: str
        :param triad_season_start_year: A year indicating the Triad season starting on 1 November of the given year, e.g. 2021.
        :type triad_season_start_year: int
        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_peak_indicative_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_peak_indicative_get_with_http_info(data, triad_season_start_year, var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_peak_indicative_get_with_http_info(self, data : Annotated[StrictStr, Field(..., description="The type of data. Supports values of 'operational' or 'settlement'.")], triad_season_start_year : Annotated[Optional[StrictInt], Field(description="A year indicating the Triad season starting on 1 November of the given year, e.g. 2021.")] = None, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Indicative Demand Peaks  # noqa: E501

        Indicative Demand Peaks using Operational Metering data are daily maxima values determined from  ITSDO and FUELHH data used to determine and visualise Triad.                Indicative Demand Peaks using Settlement Metering data are daily maxima values determined from  metered volume data from the S0142_bpi file. These peaks are not used for Triad visualisation as  they are always calculated based on the latest run type. Triads for settlement data  remain static after the National Grid report posted at the beginning of April after the Triad season has ended.                 If no filters are supplied, results default to the latest or current Triad season.  To specify a custom filter, you can supplier EITHER a Triad season start year, OR a date range, but not both.  If a Triad Season Start year is supplied, data for the Triad season beginning on 1 November  of the specified year will be returned.  If a date range is supplied, data will be returned for settlement dates within the date range inclusively.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_get_with_http_info(data, triad_season_start_year, var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param data: The type of data. Supports values of 'operational' or 'settlement'. (required)
        :type data: str
        :param triad_season_start_year: A year indicating the Triad season starting on 1 November of the given year, e.g. 2021.
        :type triad_season_start_year: int
        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'data',
            'triad_season_start_year',
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_peak_indicative_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('data') is not None:  # noqa: E501
            _query_params.append(('data', _params['data']))

        if _params.get('triad_season_start_year') is not None:  # noqa: E501
            _query_params.append(('triadSeasonStartYear', _params['triad_season_start_year']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], date):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], date):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/peak/indicative', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_peak_indicative_operational_triad_season_get(self, triad_season : Annotated[StrictInt, Field(..., description="A year indicating the Triad season starting on 1 November of the given year")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak:  # noqa: E501
        """Operational Data Demand Peak from a Triad Season  # noqa: E501

        Provides indicative demand peak data for a Triad season ITSDO and FUELHH files over a Triad season. For non-Triad  season dates please use the `peak/indicative` endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_operational_triad_season_get(triad_season, format, async_req=True)
        >>> result = thread.get()

        :param triad_season: A year indicating the Triad season starting on 1 November of the given year (required)
        :type triad_season: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_peak_indicative_operational_triad_season_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_peak_indicative_operational_triad_season_get_with_http_info(triad_season, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_peak_indicative_operational_triad_season_get_with_http_info(self, triad_season : Annotated[StrictInt, Field(..., description="A year indicating the Triad season starting on 1 November of the given year")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Operational Data Demand Peak from a Triad Season  # noqa: E501

        Provides indicative demand peak data for a Triad season ITSDO and FUELHH files over a Triad season. For non-Triad  season dates please use the `peak/indicative` endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_operational_triad_season_get_with_http_info(triad_season, format, async_req=True)
        >>> result = thread.get()

        :param triad_season: A year indicating the Triad season starting on 1 November of the given year (required)
        :type triad_season: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'triad_season',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_peak_indicative_operational_triad_season_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['triad_season']:
            _path_params['triadSeason'] = _params['triad_season']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak",
        }

        return self.api_client.call_api(
            '/demand/peak/indicative/operational/{triadSeason}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_peak_indicative_settlement_triad_season_get(self, triad_season : Annotated[StrictInt, Field(..., description="A year indicating the Triad season starting on 1 November of the given year")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak:  # noqa: E501
        """Settlement Data Demand Peak from a Triad Season  # noqa: E501

        Provides indicative demand peak data for a Triad season from S0142_bpi files that were calculated  during the Triad season. For the data from the latest settlement runs for the Triad season use the  `peak/indicative` endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_settlement_triad_season_get(triad_season, format, async_req=True)
        >>> result = thread.get()

        :param triad_season: A year indicating the Triad season starting on 1 November of the given year (required)
        :type triad_season: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_peak_indicative_settlement_triad_season_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_peak_indicative_settlement_triad_season_get_with_http_info(triad_season, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_peak_indicative_settlement_triad_season_get_with_http_info(self, triad_season : Annotated[StrictInt, Field(..., description="A year indicating the Triad season starting on 1 November of the given year")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Settlement Data Demand Peak from a Triad Season  # noqa: E501

        Provides indicative demand peak data for a Triad season from S0142_bpi files that were calculated  during the Triad season. For the data from the latest settlement runs for the Triad season use the  `peak/indicative` endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_indicative_settlement_triad_season_get_with_http_info(triad_season, format, async_req=True)
        >>> result = thread.get()

        :param triad_season: A year indicating the Triad season starting on 1 November of the given year (required)
        :type triad_season: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'triad_season',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_peak_indicative_settlement_triad_season_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['triad_season']:
            _path_params['triadSeason'] = _params['triad_season']


        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak",
        }

        return self.api_client.call_api(
            '/demand/peak/indicative/settlement/{triadSeason}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_peak_triad_get(self, data : Annotated[StrictStr, Field(..., description="The type of data. Supports values of 'operational' or 'settlement'.")], triad_season_start_year : Annotated[Optional[StrictInt], Field(description="A year indicating the Triad season starting on 1 November of the given year.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak:  # noqa: E501
        """Triad Demand Peaks  # noqa: E501

        Operational Triad peaks are calculated from the indicative demand peaks data.    Settlement Triad Peaks are calculated from the latest metered volume data available at the point one month following the Triad season's end.  For any Triad season still in progress, the latest run type data is used.                All Triad peaks are at least 10 days clear of one another.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_triad_get(data, triad_season_start_year, format, async_req=True)
        >>> result = thread.get()

        :param data: The type of data. Supports values of 'operational' or 'settlement'. (required)
        :type data: str
        :param triad_season_start_year: A year indicating the Triad season starting on 1 November of the given year.
        :type triad_season_start_year: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_peak_triad_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_peak_triad_get_with_http_info(data, triad_season_start_year, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_peak_triad_get_with_http_info(self, data : Annotated[StrictStr, Field(..., description="The type of data. Supports values of 'operational' or 'settlement'.")], triad_season_start_year : Annotated[Optional[StrictInt], Field(description="A year indicating the Triad season starting on 1 November of the given year.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Triad Demand Peaks  # noqa: E501

        Operational Triad peaks are calculated from the indicative demand peaks data.    Settlement Triad Peaks are calculated from the latest metered volume data available at the point one month following the Triad season's end.  For any Triad season still in progress, the latest run type data is used.                All Triad peaks are at least 10 days clear of one another.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_peak_triad_get_with_http_info(data, triad_season_start_year, format, async_req=True)
        >>> result = thread.get()

        :param data: The type of data. Supports values of 'operational' or 'settlement'. (required)
        :type data: str
        :param triad_season_start_year: A year indicating the Triad season starting on 1 November of the given year.
        :type triad_season_start_year: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'data',
            'triad_season_start_year',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_peak_triad_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('data') is not None:  # noqa: E501
            _query_params.append(('data', _params['data']))

        if _params.get('triad_season_start_year') is not None:  # noqa: E501
            _query_params.append(('triadSeasonStartYear', _params['triad_season_start_year']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnIndicativeDemandPeak",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/peak/triad', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_rolling_system_demand_get(self, var_from : Optional[datetime] = None, to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnRollingSystemDemand:  # noqa: E501
        """Rolling System Demand (ROLSYSDEM)  # noqa: E501

        This endpoint provides the Rolling System Data and this is derived from the total  of all Fuel Type categories from the Generation by Fuel Type report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_rolling_system_demand_get(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from:
        :type var_from: datetime
        :param to:
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnRollingSystemDemand
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_rolling_system_demand_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_rolling_system_demand_get_with_http_info(var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_rolling_system_demand_get_with_http_info(self, var_from : Optional[datetime] = None, to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Rolling System Demand (ROLSYSDEM)  # noqa: E501

        This endpoint provides the Rolling System Data and this is derived from the total  of all Fuel Type categories from the Generation by Fuel Type report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_rolling_system_demand_get_with_http_info(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from:
        :type var_from: datetime
        :param to:
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnRollingSystemDemand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_rolling_system_demand_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandOutturnRollingSystemDemand",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/rollingSystemDemand', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_stream_get(self, settlement_date_from : Annotated[Optional[date], Field(description="The settlement date from for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_date_to : Annotated[Optional[date], Field(description="The settlement date to for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_period : Optional[conlist(StrictInt, unique_items=True)] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandOutturnDemandOutturn]:  # noqa: E501
        """Initial National Demand Outturn Stream  # noqa: E501

        This endpoint provides data for Initial National Demand Outturn, which measures the  half-hour average MW demand metered by the Transmission Company based on its operational metering.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period. The data is represented with:  - INDO (Initial National Demand Outturn) which takes into account transmission losses but does not include station transformer load, pumped storage demand or interconnector demand.  - ITSDO (Initial Transmission System Demand Outturn) which takes into account transmission losses, station transformer load, pumped storage demand and interconnector demand.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the initial national demand outturn data.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_stream_get(settlement_date_from, settlement_date_to, settlement_period, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from: The settlement date from for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_from: date
        :param settlement_date_to: The settlement date to for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_to: date
        :param settlement_period:
        :type settlement_period: List[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandOutturnDemandOutturn]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_stream_get_with_http_info(settlement_date_from, settlement_date_to, settlement_period, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_stream_get_with_http_info(self, settlement_date_from : Annotated[Optional[date], Field(description="The settlement date from for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_date_to : Annotated[Optional[date], Field(description="The settlement date to for the filter. This must be in the format yyyy-MM-dd.")] = None, settlement_period : Optional[conlist(StrictInt, unique_items=True)] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initial National Demand Outturn Stream  # noqa: E501

        This endpoint provides data for Initial National Demand Outturn, which measures the  half-hour average MW demand metered by the Transmission Company based on its operational metering.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period. The data is represented with:  - INDO (Initial National Demand Outturn) which takes into account transmission losses but does not include station transformer load, pumped storage demand or interconnector demand.  - ITSDO (Initial Transmission System Demand Outturn) which takes into account transmission losses, station transformer load, pumped storage demand and interconnector demand.                This endpoint has an optimised JSON payload and is aimed at frequent requests for the initial national demand outturn data.                Settlement date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_stream_get_with_http_info(settlement_date_from, settlement_date_to, settlement_period, async_req=True)
        >>> result = thread.get()

        :param settlement_date_from: The settlement date from for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_from: date
        :param settlement_date_to: The settlement date to for the filter. This must be in the format yyyy-MM-dd.
        :type settlement_date_to: date
        :param settlement_period:
        :type settlement_period: List[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandOutturnDemandOutturn], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date_from',
            'settlement_date_to',
            'settlement_period'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date_from') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_from'], date):
                _query_params.append(('settlementDateFrom', _params['settlement_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateFrom', _params['settlement_date_from']))

        if _params.get('settlement_date_to') is not None:  # noqa: E501
            if isinstance(_params['settlement_date_to'], date):
                _query_params.append(('settlementDateTo', _params['settlement_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDateTo', _params['settlement_date_to']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandOutturnDemandOutturn]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def demand_summary_get(self, var_from : Optional[datetime] = None, to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> List[InsightsApiModelsResponsesDemandOutturnRollingSystemDemand]:  # noqa: E501
        """System Demand Summary  # noqa: E501

         This endpoint provides a down-sampled data summary intended for visualisation purposes.  Use datasets endpoints for full dataset access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_summary_get(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from:
        :type var_from: datetime
        :param to:
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsResponsesDemandOutturnRollingSystemDemand]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the demand_summary_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.demand_summary_get_with_http_info(var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def demand_summary_get_with_http_info(self, var_from : Optional[datetime] = None, to : Optional[datetime] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """System Demand Summary  # noqa: E501

         This endpoint provides a down-sampled data summary intended for visualisation purposes.  Use datasets endpoints for full dataset access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.demand_summary_get_with_http_info(var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param var_from:
        :type var_from: datetime
        :param to:
        :type to: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsResponsesDemandOutturnRollingSystemDemand], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method demand_summary_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsResponsesDemandOutturnRollingSystemDemand]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/demand/summary', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
