# coding: utf-8

"""
    Insights.Api

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import date, datetime

from pydantic import Field, StrictInt, StrictStr, conlist

from typing import List, Optional

from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_forecast_demand_forecast_daily import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_forecast_demand_forecast_day_ahead import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_forecast_demand_forecast_peak import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastPeak
from openapi_client.models.insights_api_models_responses_response_with_metadata1_insights_api_models_responses_demand_forecast_demand_forecast_weekly import InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly
from openapi_client.models.insights_api_models_service_day_ahead_demand_forecast_row import InsightsApiModelsServiceDayAheadDemandForecastRow

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DemandForecastApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def forecast_demand_daily_evolution_get(self, forecast_date : Annotated[date, Field(..., description="The forecast date for the filter. This must be in the format yyyy-MM-dd.")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily:  # noqa: E501
        """Evolution Daily Demand Forecast  # noqa: E501

        This endpoint provides the evolution of all daily demand forecasts over time for a given forecast date.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_evolution_get(forecast_date, format, async_req=True)
        >>> result = thread.get()

        :param forecast_date: The forecast date for the filter. This must be in the format yyyy-MM-dd. (required)
        :type forecast_date: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_daily_evolution_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_daily_evolution_get_with_http_info(forecast_date, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_daily_evolution_get_with_http_info(self, forecast_date : Annotated[date, Field(..., description="The forecast date for the filter. This must be in the format yyyy-MM-dd.")], format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Evolution Daily Demand Forecast  # noqa: E501

        This endpoint provides the evolution of all daily demand forecasts over time for a given forecast date.                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_evolution_get_with_http_info(forecast_date, format, async_req=True)
        >>> result = thread.get()

        :param forecast_date: The forecast date for the filter. This must be in the format yyyy-MM-dd. (required)
        :type forecast_date: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'forecast_date',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_daily_evolution_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('forecast_date') is not None:  # noqa: E501
            if isinstance(_params['forecast_date'], date):
                _query_params.append(('forecastDate', _params['forecast_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('forecastDate', _params['forecast_date']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/daily/evolution', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_daily_get(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily:  # noqa: E501
        """Fourteen day forecast demand  # noqa: E501

        Retrieve latest 14-day forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_get(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_daily_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_daily_get_with_http_info(format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_daily_get_with_http_info(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Fourteen day forecast demand  # noqa: E501

        Retrieve latest 14-day forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_get_with_http_info(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_daily_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily",
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/daily', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_daily_history_get(self, publish_time : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily:  # noqa: E501
        """Historical daily forecast demand  # noqa: E501

        Retrieve historical daily forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_history_get(publish_time, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_daily_history_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_daily_history_get_with_http_info(publish_time, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_daily_history_get_with_http_info(self, publish_time : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Historical daily forecast demand  # noqa: E501

        Retrieve historical daily forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_daily_history_get_with_http_info(publish_time, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_time',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_daily_history_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_time') is not None:  # noqa: E501
            if isinstance(_params['publish_time'], datetime):
                _query_params.append(('publishTime', _params['publish_time'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishTime', _params['publish_time']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDaily",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/daily/history', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_earliest_get(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead:  # noqa: E501
        """Earliest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving earliest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the earliest published forecast for each settlement period is shown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_earliest_get(var_from, to, boundary, format, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_earliest_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_earliest_get_with_http_info(var_from, to, boundary, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_earliest_get_with_http_info(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Earliest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving earliest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the earliest published forecast for each settlement period is shown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_earliest_get_with_http_info(var_from, to, boundary, format, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'boundary',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_earliest_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/earliest', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_earliest_stream_get(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, **kwargs) -> List[InsightsApiModelsServiceDayAheadDemandForecastRow]:  # noqa: E501
        """Stream of earliest day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving a stream of earliest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the earliest published forecast for each settlement period is shown.  This endpoint has an optimised JSON payload and aimed at frequent request for the day-ahead demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_earliest_stream_get(var_from, to, boundary, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsServiceDayAheadDemandForecastRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_earliest_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_earliest_stream_get_with_http_info(var_from, to, boundary, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_earliest_stream_get_with_http_info(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream of earliest day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving a stream of earliest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the earliest published forecast for each settlement period is shown.  This endpoint has an optimised JSON payload and aimed at frequent request for the day-ahead demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_earliest_stream_get_with_http_info(var_from, to, boundary, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsServiceDayAheadDemandForecastRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'boundary'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_earliest_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsServiceDayAheadDemandForecastRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/earliest/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_evolution_get(self, settlement_date : Annotated[date, Field(..., description="The settlement date for the filter. This must be in the format yyyy-MM-dd.")], settlement_period : conlist(StrictInt, unique_items=True), boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead:  # noqa: E501
        """Evolution Day-ahead Demand forecast  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_evolution_get(settlement_date, settlement_period, boundary, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date for the filter. This must be in the format yyyy-MM-dd. (required)
        :type settlement_date: date
        :param settlement_period: (required)
        :type settlement_period: List[int]
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_evolution_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_evolution_get_with_http_info(settlement_date, settlement_period, boundary, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_evolution_get_with_http_info(self, settlement_date : Annotated[date, Field(..., description="The settlement date for the filter. This must be in the format yyyy-MM-dd.")], settlement_period : conlist(StrictInt, unique_items=True), boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Evolution Day-ahead Demand forecast  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).                Date parameter must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_evolution_get_with_http_info(settlement_date, settlement_period, boundary, format, async_req=True)
        >>> result = thread.get()

        :param settlement_date: The settlement date for the filter. This must be in the format yyyy-MM-dd. (required)
        :type settlement_date: date
        :param settlement_period: (required)
        :type settlement_period: List[int]
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'settlement_date',
            'settlement_period',
            'boundary',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_evolution_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('settlement_date') is not None:  # noqa: E501
            if isinstance(_params['settlement_date'], date):
                _query_params.append(('settlementDate', _params['settlement_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('settlementDate', _params['settlement_date']))

        if _params.get('settlement_period') is not None:  # noqa: E501
            _query_params.append(('settlementPeriod', _params['settlement_period']))
            _collection_formats['settlementPeriod'] = 'multi'

        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/evolution', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_get(self, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead:  # noqa: E501
        """Day-ahead demand forecast  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_get(boundary, format, async_req=True)
        >>> result = thread.get()

        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_get_with_http_info(boundary, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_get_with_http_info(self, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Day-ahead demand forecast  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_get_with_http_info(boundary, format, async_req=True)
        >>> result = thread.get()

        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_history_get(self, publish_time : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead:  # noqa: E501
        """Historical day-ahead forecast demand  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_history_get(publish_time, boundary, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_history_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_history_get_with_http_info(publish_time, boundary, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_history_get_with_http_info(self, publish_time : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Historical day-ahead forecast demand  # noqa: E501

        This endpoint provides the day and day ahead demand forecast and are categorized as National Demand Forecast (NDF) and Transmission System Demand Forecast (TSDF);  the forecast values are derived by NGESO and is based on historically metered generation output for Great Britain.  The data is updated every 30 minutes and within 15 minutes of the end of the effective Settlement Period.  NDF takes into account transmission losses but but does not include station transformer load, pumped storage demand or Interconnector demand;  the data is reported only at national level; and TSDF which takes into account transmission losses , station transformer load, pumped storage demand and interconnector demand.  The data is reported both at national and boundary (system zones) level. Boundary data only available for Transmission System Demand Forecast (TSDF).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_history_get_with_http_info(publish_time, boundary, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_time',
            'boundary',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_history_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_time') is not None:  # noqa: E501
            if isinstance(_params['publish_time'], datetime):
                _query_params.append(('publishTime', _params['publish_time'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishTime', _params['publish_time']))

        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/history', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_latest_get(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead:  # noqa: E501
        """Latest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving latest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the latest published forecast for each settlement period is shown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_latest_get(var_from, to, boundary, format, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_latest_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_latest_get_with_http_info(var_from, to, boundary, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_latest_get_with_http_info(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Latest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving latest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the latest published forecast for each settlement period is shown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_latest_get_with_http_info(var_from, to, boundary, format, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'boundary',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_latest_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastDayAhead",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/latest', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_latest_stream_get(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, **kwargs) -> List[InsightsApiModelsServiceDayAheadDemandForecastRow]:  # noqa: E501
        """Stream of latest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving a stream of latest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the latest published forecast for each settlement period is shown.  This endpoint has an optimised JSON payload and aimed at frequent request for the day-ahead demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_latest_stream_get(var_from, to, boundary, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InsightsApiModelsServiceDayAheadDemandForecastRow]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_latest_stream_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_latest_stream_get_with_http_info(var_from, to, boundary, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_latest_stream_get_with_http_info(self, var_from : datetime, to : datetime, boundary : Annotated[Optional[StrictStr], Field(description="Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Stream of latest published day-ahead demand forecast data for a given settlement period  # noqa: E501

        This endpoint allows for retrieving a stream of latest day-ahead demand forecast data from National Grid ESO.  Results are filtered by settlement time, and only the latest published forecast for each settlement period is shown.  This endpoint has an optimised JSON payload and aimed at frequent request for the day-ahead demand forecast data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_latest_stream_get_with_http_info(var_from, to, boundary, async_req=True)
        >>> result = thread.get()

        :param var_from: (required)
        :type var_from: datetime
        :param to: (required)
        :type to: datetime
        :param boundary: Omitting this will return only national data. Specifying boundary=zonal will return only zonal data.
        :type boundary: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InsightsApiModelsServiceDayAheadDemandForecastRow], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'boundary'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_latest_stream_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[InsightsApiModelsServiceDayAheadDemandForecastRow]",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/latest/stream', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_day_ahead_peak_get(self, boundary : Optional[StrictStr] = None, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastPeak:  # noqa: E501
        """Retrieve peak demand data for each day, based on Day Ahead forecast data  # noqa: E501

        This endpoint allows for retrieving the peak demand that is forecast for each day from National Grid ESO.  Results are filtered by a range of Date parameters.  Results default to yesterday, today and tomorrow if no parameters are supplied.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_peak_get(boundary, var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastPeak
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_day_ahead_peak_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_day_ahead_peak_get_with_http_info(boundary, var_from, to, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_day_ahead_peak_get_with_http_info(self, boundary : Optional[StrictStr] = None, var_from : Annotated[Optional[date], Field(description="The start of the requested date range.")] = None, to : Annotated[Optional[date], Field(description="The end of the requested date range.")] = None, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve peak demand data for each day, based on Day Ahead forecast data  # noqa: E501

        This endpoint allows for retrieving the peak demand that is forecast for each day from National Grid ESO.  Results are filtered by a range of Date parameters.  Results default to yesterday, today and tomorrow if no parameters are supplied.                Date parameters must be provided in the exact format yyyy-MM-dd.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_day_ahead_peak_get_with_http_info(boundary, var_from, to, format, async_req=True)
        >>> result = thread.get()

        :param boundary:
        :type boundary: str
        :param var_from: The start of the requested date range.
        :type var_from: date
        :param to: The end of the requested date range.
        :type to: date
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastPeak, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'boundary',
            'var_from',
            'to',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_day_ahead_peak_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('boundary') is not None:  # noqa: E501
            _query_params.append(('boundary', _params['boundary']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], date):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], date):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastPeak",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/day-ahead/peak', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_weekly_evolution_get(self, forecast_year : StrictInt, forecast_week : StrictInt, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly:  # noqa: E501
        """Evolution Weekly Demand Forecast  # noqa: E501

        This endpoint provides all weekly demand forecasts over time for a given forecast Year and Week  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_evolution_get(forecast_year, forecast_week, format, async_req=True)
        >>> result = thread.get()

        :param forecast_year: (required)
        :type forecast_year: int
        :param forecast_week: (required)
        :type forecast_week: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_weekly_evolution_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_weekly_evolution_get_with_http_info(forecast_year, forecast_week, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_weekly_evolution_get_with_http_info(self, forecast_year : StrictInt, forecast_week : StrictInt, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Evolution Weekly Demand Forecast  # noqa: E501

        This endpoint provides all weekly demand forecasts over time for a given forecast Year and Week  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_evolution_get_with_http_info(forecast_year, forecast_week, format, async_req=True)
        >>> result = thread.get()

        :param forecast_year: (required)
        :type forecast_year: int
        :param forecast_week: (required)
        :type forecast_week: int
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'forecast_year',
            'forecast_week',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_weekly_evolution_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('forecast_year') is not None:  # noqa: E501
            _query_params.append(('forecastYear', _params['forecast_year']))

        if _params.get('forecast_week') is not None:  # noqa: E501
            _query_params.append(('forecastWeek', _params['forecast_week']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/weekly/evolution', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_weekly_get(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly:  # noqa: E501
        """Weekly forecast demand  # noqa: E501

        This endpoint provides the latest weekly forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_get(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_weekly_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_weekly_get_with_http_info(format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_weekly_get_with_http_info(self, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Weekly forecast demand  # noqa: E501

        This endpoint provides the latest weekly forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_get_with_http_info(format, async_req=True)
        >>> result = thread.get()

        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_weekly_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly",
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/weekly', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def forecast_demand_weekly_history_get(self, publish_time : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly:  # noqa: E501
        """Historical weekly forecast demand  # noqa: E501

        Retrieve historical weekly forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_history_get(publish_time, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the forecast_demand_weekly_history_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.forecast_demand_weekly_history_get_with_http_info(publish_time, format, **kwargs)  # noqa: E501

    @validate_arguments
    def forecast_demand_weekly_history_get_with_http_info(self, publish_time : datetime, format : Annotated[Optional[StrictStr], Field(description="Response data format. Use json/xml to include metadata.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Historical weekly forecast demand  # noqa: E501

        Retrieve historical weekly forecast demand data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.forecast_demand_weekly_history_get_with_http_info(publish_time, format, async_req=True)
        >>> result = thread.get()

        :param publish_time: (required)
        :type publish_time: datetime
        :param format: Response data format. Use json/xml to include metadata.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'publish_time',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method forecast_demand_weekly_history_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('publish_time') is not None:  # noqa: E501
            if isinstance(_params['publish_time'], datetime):
                _query_params.append(('publishTime', _params['publish_time'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('publishTime', _params['publish_time']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json', 'application/xml', 'text/xml', 'text/csv'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InsightsApiModelsResponsesResponseWithMetadata1InsightsApiModelsResponsesDemandForecastDemandForecastWeekly",
            '400': None,
            '500': None,
        }

        return self.api_client.call_api(
            '/forecast/demand/weekly/history', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
